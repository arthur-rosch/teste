
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Annotation
 * 
 */
export type Annotation = $Result.DefaultSelection<Prisma.$AnnotationPayload>
/**
 * Model Projects
 * 
 */
export type Projects = $Result.DefaultSelection<Prisma.$ProjectsPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model VideoRoom
 * 
 */
export type VideoRoom = $Result.DefaultSelection<Prisma.$VideoRoomPayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model EmailToken
 * 
 */
export type EmailToken = $Result.DefaultSelection<Prisma.$EmailTokenPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model FinancialRegistration
 * 
 */
export type FinancialRegistration = $Result.DefaultSelection<Prisma.$FinancialRegistrationPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model Receivable
 * 
 */
export type Receivable = $Result.DefaultSelection<Prisma.$ReceivablePayload>
/**
 * Model ExtraExpense
 * 
 */
export type ExtraExpense = $Result.DefaultSelection<Prisma.$ExtraExpensePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Privacy: {
  Public: 'Public',
  Private: 'Private'
};

export type Privacy = (typeof Privacy)[keyof typeof Privacy]


export const Status: {
  To_Do: 'To_Do',
  Analysis: 'Analysis',
  Development: 'Development',
  Testing: 'Testing',
  Completed: 'Completed'
};

export type Status = (typeof Status)[keyof typeof Status]


export const ClientType: {
  CLIENT: 'CLIENT',
  SUPPLIER: 'SUPPLIER',
  SERVICE_PROVIDER: 'SERVICE_PROVIDER'
};

export type ClientType = (typeof ClientType)[keyof typeof ClientType]


export const ExpenseType: {
  SUPPLIER: 'SUPPLIER',
  SERVICE_PROVIDER: 'SERVICE_PROVIDER'
};

export type ExpenseType = (typeof ExpenseType)[keyof typeof ExpenseType]

}

export type Privacy = $Enums.Privacy

export const Privacy: typeof $Enums.Privacy

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type ClientType = $Enums.ClientType

export const ClientType: typeof $Enums.ClientType

export type ExpenseType = $Enums.ExpenseType

export const ExpenseType: typeof $Enums.ExpenseType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.annotation`: Exposes CRUD operations for the **Annotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Annotations
    * const annotations = await prisma.annotation.findMany()
    * ```
    */
  get annotation(): Prisma.AnnotationDelegate<ExtArgs>;

  /**
   * `prisma.projects`: Exposes CRUD operations for the **Projects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.projects.findMany()
    * ```
    */
  get projects(): Prisma.ProjectsDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs>;

  /**
   * `prisma.videoRoom`: Exposes CRUD operations for the **VideoRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoRooms
    * const videoRooms = await prisma.videoRoom.findMany()
    * ```
    */
  get videoRoom(): Prisma.VideoRoomDelegate<ExtArgs>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.emailToken`: Exposes CRUD operations for the **EmailToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTokens
    * const emailTokens = await prisma.emailToken.findMany()
    * ```
    */
  get emailToken(): Prisma.EmailTokenDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.financialRegistration`: Exposes CRUD operations for the **FinancialRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialRegistrations
    * const financialRegistrations = await prisma.financialRegistration.findMany()
    * ```
    */
  get financialRegistration(): Prisma.FinancialRegistrationDelegate<ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs>;

  /**
   * `prisma.receivable`: Exposes CRUD operations for the **Receivable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receivables
    * const receivables = await prisma.receivable.findMany()
    * ```
    */
  get receivable(): Prisma.ReceivableDelegate<ExtArgs>;

  /**
   * `prisma.extraExpense`: Exposes CRUD operations for the **ExtraExpense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExtraExpenses
    * const extraExpenses = await prisma.extraExpense.findMany()
    * ```
    */
  get extraExpense(): Prisma.ExtraExpenseDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.15.1
   * Query Engine version: 12e25d8d06f6ea5a0252864dd9a03b1bb51f3022
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Annotation: 'Annotation',
    Projects: 'Projects',
    Task: 'Task',
    Room: 'Room',
    VideoRoom: 'VideoRoom',
    Chat: 'Chat',
    Message: 'Message',
    EmailToken: 'EmailToken',
    Notification: 'Notification',
    FinancialRegistration: 'FinancialRegistration',
    Client: 'Client',
    Expense: 'Expense',
    Receivable: 'Receivable',
    ExtraExpense: 'ExtraExpense'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'annotation' | 'projects' | 'task' | 'room' | 'videoRoom' | 'chat' | 'message' | 'emailToken' | 'notification' | 'financialRegistration' | 'client' | 'expense' | 'receivable' | 'extraExpense'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Annotation: {
        payload: Prisma.$AnnotationPayload<ExtArgs>
        fields: Prisma.AnnotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnotationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnotationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          findFirst: {
            args: Prisma.AnnotationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnotationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          findMany: {
            args: Prisma.AnnotationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>[]
          }
          create: {
            args: Prisma.AnnotationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          createMany: {
            args: Prisma.AnnotationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnotationCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>[]
          }
          delete: {
            args: Prisma.AnnotationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          update: {
            args: Prisma.AnnotationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          deleteMany: {
            args: Prisma.AnnotationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AnnotationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AnnotationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          aggregate: {
            args: Prisma.AnnotationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAnnotation>
          }
          groupBy: {
            args: Prisma.AnnotationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AnnotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnotationCountArgs<ExtArgs>,
            result: $Utils.Optional<AnnotationCountAggregateOutputType> | number
          }
        }
      }
      Projects: {
        payload: Prisma.$ProjectsPayload<ExtArgs>
        fields: Prisma.ProjectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload>
          }
          findFirst: {
            args: Prisma.ProjectsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload>
          }
          findMany: {
            args: Prisma.ProjectsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload>[]
          }
          create: {
            args: Prisma.ProjectsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload>
          }
          createMany: {
            args: Prisma.ProjectsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectsCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload>[]
          }
          delete: {
            args: Prisma.ProjectsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload>
          }
          update: {
            args: Prisma.ProjectsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload>
          }
          deleteMany: {
            args: Prisma.ProjectsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProjectsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProjectsPayload>
          }
          aggregate: {
            args: Prisma.ProjectsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProjects>
          }
          groupBy: {
            args: Prisma.ProjectsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectsCountArgs<ExtArgs>,
            result: $Utils.Optional<ProjectsCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>,
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      VideoRoom: {
        payload: Prisma.$VideoRoomPayload<ExtArgs>
        fields: Prisma.VideoRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoRoomFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoRoomFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>
          }
          findFirst: {
            args: Prisma.VideoRoomFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoRoomFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>
          }
          findMany: {
            args: Prisma.VideoRoomFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>[]
          }
          create: {
            args: Prisma.VideoRoomCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>
          }
          createMany: {
            args: Prisma.VideoRoomCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoRoomCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>[]
          }
          delete: {
            args: Prisma.VideoRoomDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>
          }
          update: {
            args: Prisma.VideoRoomUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>
          }
          deleteMany: {
            args: Prisma.VideoRoomDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VideoRoomUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VideoRoomUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>
          }
          aggregate: {
            args: Prisma.VideoRoomAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVideoRoom>
          }
          groupBy: {
            args: Prisma.VideoRoomGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VideoRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoRoomCountArgs<ExtArgs>,
            result: $Utils.Optional<VideoRoomCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>,
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>,
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      EmailToken: {
        payload: Prisma.$EmailTokenPayload<ExtArgs>
        fields: Prisma.EmailTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTokenPayload>
          }
          findFirst: {
            args: Prisma.EmailTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTokenPayload>
          }
          findMany: {
            args: Prisma.EmailTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTokenPayload>[]
          }
          create: {
            args: Prisma.EmailTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTokenPayload>
          }
          createMany: {
            args: Prisma.EmailTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTokenCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTokenPayload>[]
          }
          delete: {
            args: Prisma.EmailTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTokenPayload>
          }
          update: {
            args: Prisma.EmailTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTokenPayload>
          }
          deleteMany: {
            args: Prisma.EmailTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTokenPayload>
          }
          aggregate: {
            args: Prisma.EmailTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailToken>
          }
          groupBy: {
            args: Prisma.EmailTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailTokenCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      FinancialRegistration: {
        payload: Prisma.$FinancialRegistrationPayload<ExtArgs>
        fields: Prisma.FinancialRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialRegistrationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FinancialRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialRegistrationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FinancialRegistrationPayload>
          }
          findFirst: {
            args: Prisma.FinancialRegistrationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FinancialRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialRegistrationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FinancialRegistrationPayload>
          }
          findMany: {
            args: Prisma.FinancialRegistrationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FinancialRegistrationPayload>[]
          }
          create: {
            args: Prisma.FinancialRegistrationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FinancialRegistrationPayload>
          }
          createMany: {
            args: Prisma.FinancialRegistrationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialRegistrationCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FinancialRegistrationPayload>[]
          }
          delete: {
            args: Prisma.FinancialRegistrationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FinancialRegistrationPayload>
          }
          update: {
            args: Prisma.FinancialRegistrationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FinancialRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.FinancialRegistrationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialRegistrationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FinancialRegistrationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FinancialRegistrationPayload>
          }
          aggregate: {
            args: Prisma.FinancialRegistrationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFinancialRegistration>
          }
          groupBy: {
            args: Prisma.FinancialRegistrationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FinancialRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialRegistrationCountArgs<ExtArgs>,
            result: $Utils.Optional<FinancialRegistrationCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>,
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      Receivable: {
        payload: Prisma.$ReceivablePayload<ExtArgs>
        fields: Prisma.ReceivableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceivableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceivableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>
          }
          findFirst: {
            args: Prisma.ReceivableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceivableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>
          }
          findMany: {
            args: Prisma.ReceivableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>[]
          }
          create: {
            args: Prisma.ReceivableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>
          }
          createMany: {
            args: Prisma.ReceivableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceivableCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>[]
          }
          delete: {
            args: Prisma.ReceivableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>
          }
          update: {
            args: Prisma.ReceivableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>
          }
          deleteMany: {
            args: Prisma.ReceivableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReceivableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReceivableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>
          }
          aggregate: {
            args: Prisma.ReceivableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReceivable>
          }
          groupBy: {
            args: Prisma.ReceivableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReceivableGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceivableCountArgs<ExtArgs>,
            result: $Utils.Optional<ReceivableCountAggregateOutputType> | number
          }
        }
      }
      ExtraExpense: {
        payload: Prisma.$ExtraExpensePayload<ExtArgs>
        fields: Prisma.ExtraExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExtraExpenseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExtraExpenseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraExpensePayload>
          }
          findFirst: {
            args: Prisma.ExtraExpenseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExtraExpenseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraExpensePayload>
          }
          findMany: {
            args: Prisma.ExtraExpenseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraExpensePayload>[]
          }
          create: {
            args: Prisma.ExtraExpenseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraExpensePayload>
          }
          createMany: {
            args: Prisma.ExtraExpenseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExtraExpenseCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraExpensePayload>[]
          }
          delete: {
            args: Prisma.ExtraExpenseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraExpensePayload>
          }
          update: {
            args: Prisma.ExtraExpenseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExtraExpenseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ExtraExpenseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ExtraExpenseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExtraExpensePayload>
          }
          aggregate: {
            args: Prisma.ExtraExpenseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExtraExpense>
          }
          groupBy: {
            args: Prisma.ExtraExpenseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ExtraExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExtraExpenseCountArgs<ExtArgs>,
            result: $Utils.Optional<ExtraExpenseCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    rooms: number
    ownedRooms: number
    projects: number
    messages: number
    ownedProjects: number
    tasks: number
    annotation: number
    emailToken: number
    notification: number
    sendNotification: number
    videoRoom: number
    financialRegistration: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | UserCountOutputTypeCountRoomsArgs
    ownedRooms?: boolean | UserCountOutputTypeCountOwnedRoomsArgs
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    ownedProjects?: boolean | UserCountOutputTypeCountOwnedProjectsArgs
    tasks?: boolean | UserCountOutputTypeCountTasksArgs
    annotation?: boolean | UserCountOutputTypeCountAnnotationArgs
    emailToken?: boolean | UserCountOutputTypeCountEmailTokenArgs
    notification?: boolean | UserCountOutputTypeCountNotificationArgs
    sendNotification?: boolean | UserCountOutputTypeCountSendNotificationArgs
    videoRoom?: boolean | UserCountOutputTypeCountVideoRoomArgs
    financialRegistration?: boolean | UserCountOutputTypeCountFinancialRegistrationArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnotationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSendNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVideoRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoRoomWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFinancialRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialRegistrationWhereInput
  }


  /**
   * Count Type ProjectsCountOutputType
   */

  export type ProjectsCountOutputType = {
    users: number
    tasks: number
  }

  export type ProjectsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ProjectsCountOutputTypeCountUsersArgs
    tasks?: boolean | ProjectsCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ProjectsCountOutputType without action
   */
  export type ProjectsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectsCountOutputType
     */
    select?: ProjectsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectsCountOutputType without action
   */
  export type ProjectsCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ProjectsCountOutputType without action
   */
  export type ProjectsCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    chats: number
    users: number
    VideoRoom: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | RoomCountOutputTypeCountChatsArgs
    users?: boolean | RoomCountOutputTypeCountUsersArgs
    VideoRoom?: boolean | RoomCountOutputTypeCountVideoRoomArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountVideoRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoRoomWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    messages: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type FinancialRegistrationCountOutputType
   */

  export type FinancialRegistrationCountOutputType = {
    clients: number
    expenses: number
    Receivable: number
    ExtraExpense: number
  }

  export type FinancialRegistrationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | FinancialRegistrationCountOutputTypeCountClientsArgs
    expenses?: boolean | FinancialRegistrationCountOutputTypeCountExpensesArgs
    Receivable?: boolean | FinancialRegistrationCountOutputTypeCountReceivableArgs
    ExtraExpense?: boolean | FinancialRegistrationCountOutputTypeCountExtraExpenseArgs
  }

  // Custom InputTypes
  /**
   * FinancialRegistrationCountOutputType without action
   */
  export type FinancialRegistrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRegistrationCountOutputType
     */
    select?: FinancialRegistrationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FinancialRegistrationCountOutputType without action
   */
  export type FinancialRegistrationCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * FinancialRegistrationCountOutputType without action
   */
  export type FinancialRegistrationCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * FinancialRegistrationCountOutputType without action
   */
  export type FinancialRegistrationCountOutputTypeCountReceivableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivableWhereInput
  }

  /**
   * FinancialRegistrationCountOutputType without action
   */
  export type FinancialRegistrationCountOutputTypeCountExtraExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExtraExpenseWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    Receivable: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receivable?: boolean | ClientCountOutputTypeCountReceivableArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountReceivableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivableWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    phone: string | null
    gender: string | null
    dateBirth: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    phone: string | null
    gender: string | null
    dateBirth: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    phone: number
    gender: number
    dateBirth: number
    password: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    phone?: true
    gender?: true
    dateBirth?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    phone?: true
    gender?: true
    dateBirth?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    phone?: true
    gender?: true
    dateBirth?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    gender?: boolean
    dateBirth?: boolean
    password?: boolean
    rooms?: boolean | User$roomsArgs<ExtArgs>
    ownedRooms?: boolean | User$ownedRoomsArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    ownedProjects?: boolean | User$ownedProjectsArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    annotation?: boolean | User$annotationArgs<ExtArgs>
    emailToken?: boolean | User$emailTokenArgs<ExtArgs>
    notification?: boolean | User$notificationArgs<ExtArgs>
    sendNotification?: boolean | User$sendNotificationArgs<ExtArgs>
    videoRoom?: boolean | User$videoRoomArgs<ExtArgs>
    financialRegistration?: boolean | User$financialRegistrationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    gender?: boolean
    dateBirth?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    gender?: boolean
    dateBirth?: boolean
    password?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | User$roomsArgs<ExtArgs>
    ownedRooms?: boolean | User$ownedRoomsArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    ownedProjects?: boolean | User$ownedProjectsArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    annotation?: boolean | User$annotationArgs<ExtArgs>
    emailToken?: boolean | User$emailTokenArgs<ExtArgs>
    notification?: boolean | User$notificationArgs<ExtArgs>
    sendNotification?: boolean | User$sendNotificationArgs<ExtArgs>
    videoRoom?: boolean | User$videoRoomArgs<ExtArgs>
    financialRegistration?: boolean | User$financialRegistrationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      rooms: Prisma.$RoomPayload<ExtArgs>[]
      ownedRooms: Prisma.$RoomPayload<ExtArgs>[]
      projects: Prisma.$ProjectsPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      ownedProjects: Prisma.$ProjectsPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      annotation: Prisma.$AnnotationPayload<ExtArgs>[]
      emailToken: Prisma.$EmailTokenPayload<ExtArgs>[]
      notification: Prisma.$NotificationPayload<ExtArgs>[]
      sendNotification: Prisma.$NotificationPayload<ExtArgs>[]
      videoRoom: Prisma.$VideoRoomPayload<ExtArgs>[]
      financialRegistration: Prisma.$FinancialRegistrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      phone: string
      gender: string
      dateBirth: string
      password: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends UserCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    rooms<T extends User$roomsArgs<ExtArgs> = {}>(args?: Subset<T, User$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findMany'> | Null>;

    ownedRooms<T extends User$ownedRoomsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findMany'> | Null>;

    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, 'findMany'> | Null>;

    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    ownedProjects<T extends User$ownedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, 'findMany'> | Null>;

    tasks<T extends User$tasksArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findMany'> | Null>;

    annotation<T extends User$annotationArgs<ExtArgs> = {}>(args?: Subset<T, User$annotationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, 'findMany'> | Null>;

    emailToken<T extends User$emailTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$emailTokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTokenPayload<ExtArgs>, T, 'findMany'> | Null>;

    notification<T extends User$notificationArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    sendNotification<T extends User$sendNotificationArgs<ExtArgs> = {}>(args?: Subset<T, User$sendNotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    videoRoom<T extends User$videoRoomArgs<ExtArgs> = {}>(args?: Subset<T, User$videoRoomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, 'findMany'> | Null>;

    financialRegistration<T extends User$financialRegistrationArgs<ExtArgs> = {}>(args?: Subset<T, User$financialRegistrationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialRegistrationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'String'>
    readonly dateBirth: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.rooms
   */
  export type User$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * User.ownedRooms
   */
  export type User$ownedRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    where?: ProjectsWhereInput
    orderBy?: ProjectsOrderByWithRelationInput | ProjectsOrderByWithRelationInput[]
    cursor?: ProjectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.ownedProjects
   */
  export type User$ownedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    where?: ProjectsWhereInput
    orderBy?: ProjectsOrderByWithRelationInput | ProjectsOrderByWithRelationInput[]
    cursor?: ProjectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * User.tasks
   */
  export type User$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.annotation
   */
  export type User$annotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    where?: AnnotationWhereInput
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    cursor?: AnnotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnotationScalarFieldEnum | AnnotationScalarFieldEnum[]
  }

  /**
   * User.emailToken
   */
  export type User$emailTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailToken
     */
    select?: EmailTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTokenInclude<ExtArgs> | null
    where?: EmailTokenWhereInput
    orderBy?: EmailTokenOrderByWithRelationInput | EmailTokenOrderByWithRelationInput[]
    cursor?: EmailTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailTokenScalarFieldEnum | EmailTokenScalarFieldEnum[]
  }

  /**
   * User.notification
   */
  export type User$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.sendNotification
   */
  export type User$sendNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.videoRoom
   */
  export type User$videoRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    where?: VideoRoomWhereInput
    orderBy?: VideoRoomOrderByWithRelationInput | VideoRoomOrderByWithRelationInput[]
    cursor?: VideoRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoRoomScalarFieldEnum | VideoRoomScalarFieldEnum[]
  }

  /**
   * User.financialRegistration
   */
  export type User$financialRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRegistration
     */
    select?: FinancialRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRegistrationInclude<ExtArgs> | null
    where?: FinancialRegistrationWhereInput
    orderBy?: FinancialRegistrationOrderByWithRelationInput | FinancialRegistrationOrderByWithRelationInput[]
    cursor?: FinancialRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialRegistrationScalarFieldEnum | FinancialRegistrationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Annotation
   */

  export type AggregateAnnotation = {
    _count: AnnotationCountAggregateOutputType | null
    _min: AnnotationMinAggregateOutputType | null
    _max: AnnotationMaxAggregateOutputType | null
  }

  export type AnnotationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    color: string | null
    information: string | null
  }

  export type AnnotationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    color: string | null
    information: string | null
  }

  export type AnnotationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    color: number
    information: number
    _all: number
  }


  export type AnnotationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    color?: true
    information?: true
  }

  export type AnnotationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    color?: true
    information?: true
  }

  export type AnnotationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    color?: true
    information?: true
    _all?: true
  }

  export type AnnotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Annotation to aggregate.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Annotations
    **/
    _count?: true | AnnotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnotationMaxAggregateInputType
  }

  export type GetAnnotationAggregateType<T extends AnnotationAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnotation[P]>
      : GetScalarType<T[P], AggregateAnnotation[P]>
  }




  export type AnnotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnotationWhereInput
    orderBy?: AnnotationOrderByWithAggregationInput | AnnotationOrderByWithAggregationInput[]
    by: AnnotationScalarFieldEnum[] | AnnotationScalarFieldEnum
    having?: AnnotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnotationCountAggregateInputType | true
    _min?: AnnotationMinAggregateInputType
    _max?: AnnotationMaxAggregateInputType
  }

  export type AnnotationGroupByOutputType = {
    id: string
    userId: string
    title: string
    color: string
    information: string
    _count: AnnotationCountAggregateOutputType | null
    _min: AnnotationMinAggregateOutputType | null
    _max: AnnotationMaxAggregateOutputType | null
  }

  type GetAnnotationGroupByPayload<T extends AnnotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnotationGroupByOutputType[P]>
            : GetScalarType<T[P], AnnotationGroupByOutputType[P]>
        }
      >
    >


  export type AnnotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    color?: boolean
    information?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["annotation"]>

  export type AnnotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    color?: boolean
    information?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["annotation"]>

  export type AnnotationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    color?: boolean
    information?: boolean
  }

  export type AnnotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnnotationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnnotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Annotation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      color: string
      information: string
    }, ExtArgs["result"]["annotation"]>
    composites: {}
  }

  type AnnotationGetPayload<S extends boolean | null | undefined | AnnotationDefaultArgs> = $Result.GetResult<Prisma.$AnnotationPayload, S>

  type AnnotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnnotationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnnotationCountAggregateInputType | true
    }

  export interface AnnotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Annotation'], meta: { name: 'Annotation' } }
    /**
     * Find zero or one Annotation that matches the filter.
     * @param {AnnotationFindUniqueArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AnnotationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AnnotationFindUniqueArgs<ExtArgs>>
    ): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Annotation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnnotationFindUniqueOrThrowArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AnnotationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnotationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Annotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationFindFirstArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AnnotationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnotationFindFirstArgs<ExtArgs>>
    ): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Annotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationFindFirstOrThrowArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AnnotationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnotationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Annotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Annotations
     * const annotations = await prisma.annotation.findMany()
     * 
     * // Get first 10 Annotations
     * const annotations = await prisma.annotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const annotationWithIdOnly = await prisma.annotation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AnnotationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnotationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Annotation.
     * @param {AnnotationCreateArgs} args - Arguments to create a Annotation.
     * @example
     * // Create one Annotation
     * const Annotation = await prisma.annotation.create({
     *   data: {
     *     // ... data to create a Annotation
     *   }
     * })
     * 
    **/
    create<T extends AnnotationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AnnotationCreateArgs<ExtArgs>>
    ): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Annotations.
     * @param {AnnotationCreateManyArgs} args - Arguments to create many Annotations.
     * @example
     * // Create many Annotations
     * const annotation = await prisma.annotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AnnotationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnotationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Annotations and returns the data saved in the database.
     * @param {AnnotationCreateManyAndReturnArgs} args - Arguments to create many Annotations.
     * @example
     * // Create many Annotations
     * const annotation = await prisma.annotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Annotations and only return the `id`
     * const annotationWithIdOnly = await prisma.annotation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends AnnotationCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnotationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Annotation.
     * @param {AnnotationDeleteArgs} args - Arguments to delete one Annotation.
     * @example
     * // Delete one Annotation
     * const Annotation = await prisma.annotation.delete({
     *   where: {
     *     // ... filter to delete one Annotation
     *   }
     * })
     * 
    **/
    delete<T extends AnnotationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AnnotationDeleteArgs<ExtArgs>>
    ): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Annotation.
     * @param {AnnotationUpdateArgs} args - Arguments to update one Annotation.
     * @example
     * // Update one Annotation
     * const annotation = await prisma.annotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AnnotationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AnnotationUpdateArgs<ExtArgs>>
    ): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Annotations.
     * @param {AnnotationDeleteManyArgs} args - Arguments to filter Annotations to delete.
     * @example
     * // Delete a few Annotations
     * const { count } = await prisma.annotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AnnotationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnotationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Annotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Annotations
     * const annotation = await prisma.annotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AnnotationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AnnotationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Annotation.
     * @param {AnnotationUpsertArgs} args - Arguments to update or create a Annotation.
     * @example
     * // Update or create a Annotation
     * const annotation = await prisma.annotation.upsert({
     *   create: {
     *     // ... data to create a Annotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Annotation we want to update
     *   }
     * })
    **/
    upsert<T extends AnnotationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AnnotationUpsertArgs<ExtArgs>>
    ): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Annotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationCountArgs} args - Arguments to filter Annotations to count.
     * @example
     * // Count the number of Annotations
     * const count = await prisma.annotation.count({
     *   where: {
     *     // ... the filter for the Annotations we want to count
     *   }
     * })
    **/
    count<T extends AnnotationCountArgs>(
      args?: Subset<T, AnnotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Annotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnotationAggregateArgs>(args: Subset<T, AnnotationAggregateArgs>): Prisma.PrismaPromise<GetAnnotationAggregateType<T>>

    /**
     * Group by Annotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnotationGroupByArgs['orderBy'] }
        : { orderBy?: AnnotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Annotation model
   */
  readonly fields: AnnotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Annotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Annotation model
   */ 
  interface AnnotationFieldRefs {
    readonly id: FieldRef<"Annotation", 'String'>
    readonly userId: FieldRef<"Annotation", 'String'>
    readonly title: FieldRef<"Annotation", 'String'>
    readonly color: FieldRef<"Annotation", 'String'>
    readonly information: FieldRef<"Annotation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Annotation findUnique
   */
  export type AnnotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter, which Annotation to fetch.
     */
    where: AnnotationWhereUniqueInput
  }

  /**
   * Annotation findUniqueOrThrow
   */
  export type AnnotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter, which Annotation to fetch.
     */
    where: AnnotationWhereUniqueInput
  }

  /**
   * Annotation findFirst
   */
  export type AnnotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter, which Annotation to fetch.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Annotations.
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Annotations.
     */
    distinct?: AnnotationScalarFieldEnum | AnnotationScalarFieldEnum[]
  }

  /**
   * Annotation findFirstOrThrow
   */
  export type AnnotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter, which Annotation to fetch.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Annotations.
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Annotations.
     */
    distinct?: AnnotationScalarFieldEnum | AnnotationScalarFieldEnum[]
  }

  /**
   * Annotation findMany
   */
  export type AnnotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter, which Annotations to fetch.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Annotations.
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    distinct?: AnnotationScalarFieldEnum | AnnotationScalarFieldEnum[]
  }

  /**
   * Annotation create
   */
  export type AnnotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * The data needed to create a Annotation.
     */
    data: XOR<AnnotationCreateInput, AnnotationUncheckedCreateInput>
  }

  /**
   * Annotation createMany
   */
  export type AnnotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Annotations.
     */
    data: AnnotationCreateManyInput | AnnotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Annotation createManyAndReturn
   */
  export type AnnotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Annotations.
     */
    data: AnnotationCreateManyInput | AnnotationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Annotation update
   */
  export type AnnotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * The data needed to update a Annotation.
     */
    data: XOR<AnnotationUpdateInput, AnnotationUncheckedUpdateInput>
    /**
     * Choose, which Annotation to update.
     */
    where: AnnotationWhereUniqueInput
  }

  /**
   * Annotation updateMany
   */
  export type AnnotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Annotations.
     */
    data: XOR<AnnotationUpdateManyMutationInput, AnnotationUncheckedUpdateManyInput>
    /**
     * Filter which Annotations to update
     */
    where?: AnnotationWhereInput
  }

  /**
   * Annotation upsert
   */
  export type AnnotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * The filter to search for the Annotation to update in case it exists.
     */
    where: AnnotationWhereUniqueInput
    /**
     * In case the Annotation found by the `where` argument doesn't exist, create a new Annotation with this data.
     */
    create: XOR<AnnotationCreateInput, AnnotationUncheckedCreateInput>
    /**
     * In case the Annotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnotationUpdateInput, AnnotationUncheckedUpdateInput>
  }

  /**
   * Annotation delete
   */
  export type AnnotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter which Annotation to delete.
     */
    where: AnnotationWhereUniqueInput
  }

  /**
   * Annotation deleteMany
   */
  export type AnnotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Annotations to delete
     */
    where?: AnnotationWhereInput
  }

  /**
   * Annotation without action
   */
  export type AnnotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
  }


  /**
   * Model Projects
   */

  export type AggregateProjects = {
    _count: ProjectsCountAggregateOutputType | null
    _min: ProjectsMinAggregateOutputType | null
    _max: ProjectsMaxAggregateOutputType | null
  }

  export type ProjectsMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    ownerId: string | null
    privacy: $Enums.Privacy | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    ownerId: string | null
    privacy: $Enums.Privacy | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectsCountAggregateOutputType = {
    id: number
    name: number
    color: number
    ownerId: number
    usersIds: number
    privacy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectsMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    ownerId?: true
    privacy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectsMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    ownerId?: true
    privacy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectsCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    ownerId?: true
    usersIds?: true
    privacy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to aggregate.
     */
    where?: ProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectsOrderByWithRelationInput | ProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectsMaxAggregateInputType
  }

  export type GetProjectsAggregateType<T extends ProjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateProjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjects[P]>
      : GetScalarType<T[P], AggregateProjects[P]>
  }




  export type ProjectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectsWhereInput
    orderBy?: ProjectsOrderByWithAggregationInput | ProjectsOrderByWithAggregationInput[]
    by: ProjectsScalarFieldEnum[] | ProjectsScalarFieldEnum
    having?: ProjectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectsCountAggregateInputType | true
    _min?: ProjectsMinAggregateInputType
    _max?: ProjectsMaxAggregateInputType
  }

  export type ProjectsGroupByOutputType = {
    id: string
    name: string
    color: string
    ownerId: string
    usersIds: string[]
    privacy: $Enums.Privacy
    createdAt: Date
    updatedAt: Date
    _count: ProjectsCountAggregateOutputType | null
    _min: ProjectsMinAggregateOutputType | null
    _max: ProjectsMaxAggregateOutputType | null
  }

  type GetProjectsGroupByPayload<T extends ProjectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectsGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectsGroupByOutputType[P]>
        }
      >
    >


  export type ProjectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    ownerId?: boolean
    usersIds?: boolean
    privacy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Projects$usersArgs<ExtArgs>
    owner?: boolean | Projects$ownerArgs<ExtArgs>
    tasks?: boolean | Projects$tasksArgs<ExtArgs>
    _count?: boolean | ProjectsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projects"]>

  export type ProjectsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    ownerId?: boolean
    usersIds?: boolean
    privacy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | Projects$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["projects"]>

  export type ProjectsSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    ownerId?: boolean
    usersIds?: boolean
    privacy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Projects$usersArgs<ExtArgs>
    owner?: boolean | Projects$ownerArgs<ExtArgs>
    tasks?: boolean | Projects$tasksArgs<ExtArgs>
    _count?: boolean | ProjectsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Projects$ownerArgs<ExtArgs>
  }

  export type $ProjectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Projects"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      owner: Prisma.$UserPayload<ExtArgs> | null
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string
      ownerId: string
      usersIds: string[]
      privacy: $Enums.Privacy
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projects"]>
    composites: {}
  }

  type ProjectsGetPayload<S extends boolean | null | undefined | ProjectsDefaultArgs> = $Result.GetResult<Prisma.$ProjectsPayload, S>

  type ProjectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectsCountAggregateInputType | true
    }

  export interface ProjectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Projects'], meta: { name: 'Projects' } }
    /**
     * Find zero or one Projects that matches the filter.
     * @param {ProjectsFindUniqueArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectsFindUniqueArgs<ExtArgs>>
    ): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Projects that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectsFindUniqueOrThrowArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProjectsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsFindFirstArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectsFindFirstArgs<ExtArgs>>
    ): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Projects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsFindFirstOrThrowArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProjectsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.projects.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.projects.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectsWithIdOnly = await prisma.projects.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Projects.
     * @param {ProjectsCreateArgs} args - Arguments to create a Projects.
     * @example
     * // Create one Projects
     * const Projects = await prisma.projects.create({
     *   data: {
     *     // ... data to create a Projects
     *   }
     * })
     * 
    **/
    create<T extends ProjectsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectsCreateArgs<ExtArgs>>
    ): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectsCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const projects = await prisma.projects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ProjectsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectsCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const projects = await prisma.projects.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectsWithIdOnly = await prisma.projects.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ProjectsCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Projects.
     * @param {ProjectsDeleteArgs} args - Arguments to delete one Projects.
     * @example
     * // Delete one Projects
     * const Projects = await prisma.projects.delete({
     *   where: {
     *     // ... filter to delete one Projects
     *   }
     * })
     * 
    **/
    delete<T extends ProjectsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectsDeleteArgs<ExtArgs>>
    ): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Projects.
     * @param {ProjectsUpdateArgs} args - Arguments to update one Projects.
     * @example
     * // Update one Projects
     * const projects = await prisma.projects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectsUpdateArgs<ExtArgs>>
    ): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectsDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.projects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProjectsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const projects = await prisma.projects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Projects.
     * @param {ProjectsUpsertArgs} args - Arguments to update or create a Projects.
     * @example
     * // Update or create a Projects
     * const projects = await prisma.projects.upsert({
     *   create: {
     *     // ... data to create a Projects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projects we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProjectsUpsertArgs<ExtArgs>>
    ): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.projects.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectsCountArgs>(
      args?: Subset<T, ProjectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectsAggregateArgs>(args: Subset<T, ProjectsAggregateArgs>): Prisma.PrismaPromise<GetProjectsAggregateType<T>>

    /**
     * Group by Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectsGroupByArgs['orderBy'] }
        : { orderBy?: ProjectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Projects model
   */
  readonly fields: ProjectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Projects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends Projects$usersArgs<ExtArgs> = {}>(args?: Subset<T, Projects$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    owner<T extends Projects$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Projects$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    tasks<T extends Projects$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Projects$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Projects model
   */ 
  interface ProjectsFieldRefs {
    readonly id: FieldRef<"Projects", 'String'>
    readonly name: FieldRef<"Projects", 'String'>
    readonly color: FieldRef<"Projects", 'String'>
    readonly ownerId: FieldRef<"Projects", 'String'>
    readonly usersIds: FieldRef<"Projects", 'String[]'>
    readonly privacy: FieldRef<"Projects", 'Privacy'>
    readonly createdAt: FieldRef<"Projects", 'DateTime'>
    readonly updatedAt: FieldRef<"Projects", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Projects findUnique
   */
  export type ProjectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where: ProjectsWhereUniqueInput
  }

  /**
   * Projects findUniqueOrThrow
   */
  export type ProjectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where: ProjectsWhereUniqueInput
  }

  /**
   * Projects findFirst
   */
  export type ProjectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectsOrderByWithRelationInput | ProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * Projects findFirstOrThrow
   */
  export type ProjectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectsOrderByWithRelationInput | ProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * Projects findMany
   */
  export type ProjectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectsOrderByWithRelationInput | ProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * Projects create
   */
  export type ProjectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * The data needed to create a Projects.
     */
    data: XOR<ProjectsCreateInput, ProjectsUncheckedCreateInput>
  }

  /**
   * Projects createMany
   */
  export type ProjectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectsCreateManyInput | ProjectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Projects createManyAndReturn
   */
  export type ProjectsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectsCreateManyInput | ProjectsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Projects update
   */
  export type ProjectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * The data needed to update a Projects.
     */
    data: XOR<ProjectsUpdateInput, ProjectsUncheckedUpdateInput>
    /**
     * Choose, which Projects to update.
     */
    where: ProjectsWhereUniqueInput
  }

  /**
   * Projects updateMany
   */
  export type ProjectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectsUpdateManyMutationInput, ProjectsUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectsWhereInput
  }

  /**
   * Projects upsert
   */
  export type ProjectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * The filter to search for the Projects to update in case it exists.
     */
    where: ProjectsWhereUniqueInput
    /**
     * In case the Projects found by the `where` argument doesn't exist, create a new Projects with this data.
     */
    create: XOR<ProjectsCreateInput, ProjectsUncheckedCreateInput>
    /**
     * In case the Projects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectsUpdateInput, ProjectsUncheckedUpdateInput>
  }

  /**
   * Projects delete
   */
  export type ProjectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
    /**
     * Filter which Projects to delete.
     */
    where: ProjectsWhereUniqueInput
  }

  /**
   * Projects deleteMany
   */
  export type ProjectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectsWhereInput
  }

  /**
   * Projects.users
   */
  export type Projects$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Projects.owner
   */
  export type Projects$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Projects.tasks
   */
  export type Projects$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Projects without action
   */
  export type ProjectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projects
     */
    select?: ProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectsInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    information: string | null
    files: string | null
    status: $Enums.Status | null
    projectId: string | null
    responsibleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    information: string | null
    files: string | null
    status: $Enums.Status | null
    projectId: string | null
    responsibleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    information: number
    files: number
    status: number
    projectId: number
    responsibleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    information?: true
    files?: true
    status?: true
    projectId?: true
    responsibleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    information?: true
    files?: true
    status?: true
    projectId?: true
    responsibleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    information?: true
    files?: true
    status?: true
    projectId?: true
    responsibleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    information: string
    files: string
    status: $Enums.Status
    projectId: string
    responsibleId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    information?: boolean
    files?: boolean
    status?: boolean
    projectId?: boolean
    responsibleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    responsible?: boolean | Task$responsibleArgs<ExtArgs>
    project?: boolean | ProjectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    information?: boolean
    files?: boolean
    status?: boolean
    projectId?: boolean
    responsibleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    responsible?: boolean | Task$responsibleArgs<ExtArgs>
    project?: boolean | ProjectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    information?: boolean
    files?: boolean
    status?: boolean
    projectId?: boolean
    responsibleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsible?: boolean | Task$responsibleArgs<ExtArgs>
    project?: boolean | ProjectsDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsible?: boolean | Task$responsibleArgs<ExtArgs>
    project?: boolean | ProjectsDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      responsible: Prisma.$UserPayload<ExtArgs> | null
      project: Prisma.$ProjectsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      information: string
      files: string
      status: $Enums.Status
      projectId: string
      responsibleId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TaskFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TaskFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TaskFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
    **/
    create<T extends TaskCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TaskCreateArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends TaskCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
    **/
    delete<T extends TaskDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TaskUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TaskDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TaskUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
    **/
    upsert<T extends TaskUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    responsible<T extends Task$responsibleArgs<ExtArgs> = {}>(args?: Subset<T, Task$responsibleArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    project<T extends ProjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectsDefaultArgs<ExtArgs>>): Prisma__ProjectsClient<$Result.GetResult<Prisma.$ProjectsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly information: FieldRef<"Task", 'String'>
    readonly files: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'Status'>
    readonly projectId: FieldRef<"Task", 'String'>
    readonly responsibleId: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }

  /**
   * Task.responsible
   */
  export type Task$responsibleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    name: string | null
    ownerId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    name: string | null
    ownerId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    name: number
    ownerId: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type RoomMinAggregateInputType = {
    id?: true
    name?: true
    ownerId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    name?: true
    ownerId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    name?: true
    ownerId?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    name: string
    ownerId: string
    updatedAt: Date
    createdAt: Date
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ownerId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    chats?: boolean | Room$chatsArgs<ExtArgs>
    users?: boolean | Room$usersArgs<ExtArgs>
    owner?: boolean | Room$ownerArgs<ExtArgs>
    VideoRoom?: boolean | Room$VideoRoomArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ownerId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    owner?: boolean | Room$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    name?: boolean
    ownerId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | Room$chatsArgs<ExtArgs>
    users?: boolean | Room$usersArgs<ExtArgs>
    owner?: boolean | Room$ownerArgs<ExtArgs>
    VideoRoom?: boolean | Room$VideoRoomArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Room$ownerArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      chats: Prisma.$ChatPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      owner: Prisma.$UserPayload<ExtArgs> | null
      VideoRoom: Prisma.$VideoRoomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      ownerId: string
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoomFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
    **/
    create<T extends RoomCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomCreateArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends RoomCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends RoomCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
    **/
    delete<T extends RoomDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
    **/
    upsert<T extends RoomUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    chats<T extends Room$chatsArgs<ExtArgs> = {}>(args?: Subset<T, Room$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, 'findMany'> | Null>;

    users<T extends Room$usersArgs<ExtArgs> = {}>(args?: Subset<T, Room$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    owner<T extends Room$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Room$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    VideoRoom<T extends Room$VideoRoomArgs<ExtArgs> = {}>(args?: Subset<T, Room$VideoRoomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Room model
   */ 
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'String'>
    readonly name: FieldRef<"Room", 'String'>
    readonly ownerId: FieldRef<"Room", 'String'>
    readonly updatedAt: FieldRef<"Room", 'DateTime'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room createManyAndReturn
   */
  export type RoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
  }

  /**
   * Room.chats
   */
  export type Room$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Room.users
   */
  export type Room$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Room.owner
   */
  export type Room$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Room.VideoRoom
   */
  export type Room$VideoRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    where?: VideoRoomWhereInput
    orderBy?: VideoRoomOrderByWithRelationInput | VideoRoomOrderByWithRelationInput[]
    cursor?: VideoRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoRoomScalarFieldEnum | VideoRoomScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model VideoRoom
   */

  export type AggregateVideoRoom = {
    _count: VideoRoomCountAggregateOutputType | null
    _min: VideoRoomMinAggregateOutputType | null
    _max: VideoRoomMaxAggregateOutputType | null
  }

  export type VideoRoomMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    roomId: string | null
    roomLink: string | null
  }

  export type VideoRoomMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    roomId: string | null
    roomLink: string | null
  }

  export type VideoRoomCountAggregateOutputType = {
    id: number
    ownerId: number
    roomId: number
    roomLink: number
    _all: number
  }


  export type VideoRoomMinAggregateInputType = {
    id?: true
    ownerId?: true
    roomId?: true
    roomLink?: true
  }

  export type VideoRoomMaxAggregateInputType = {
    id?: true
    ownerId?: true
    roomId?: true
    roomLink?: true
  }

  export type VideoRoomCountAggregateInputType = {
    id?: true
    ownerId?: true
    roomId?: true
    roomLink?: true
    _all?: true
  }

  export type VideoRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoRoom to aggregate.
     */
    where?: VideoRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoRooms to fetch.
     */
    orderBy?: VideoRoomOrderByWithRelationInput | VideoRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoRooms
    **/
    _count?: true | VideoRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoRoomMaxAggregateInputType
  }

  export type GetVideoRoomAggregateType<T extends VideoRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoRoom[P]>
      : GetScalarType<T[P], AggregateVideoRoom[P]>
  }




  export type VideoRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoRoomWhereInput
    orderBy?: VideoRoomOrderByWithAggregationInput | VideoRoomOrderByWithAggregationInput[]
    by: VideoRoomScalarFieldEnum[] | VideoRoomScalarFieldEnum
    having?: VideoRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoRoomCountAggregateInputType | true
    _min?: VideoRoomMinAggregateInputType
    _max?: VideoRoomMaxAggregateInputType
  }

  export type VideoRoomGroupByOutputType = {
    id: string
    ownerId: string
    roomId: string
    roomLink: string
    _count: VideoRoomCountAggregateOutputType | null
    _min: VideoRoomMinAggregateOutputType | null
    _max: VideoRoomMaxAggregateOutputType | null
  }

  type GetVideoRoomGroupByPayload<T extends VideoRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoRoomGroupByOutputType[P]>
            : GetScalarType<T[P], VideoRoomGroupByOutputType[P]>
        }
      >
    >


  export type VideoRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    roomId?: boolean
    roomLink?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoRoom"]>

  export type VideoRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    roomId?: boolean
    roomLink?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoRoom"]>

  export type VideoRoomSelectScalar = {
    id?: boolean
    ownerId?: boolean
    roomId?: boolean
    roomLink?: boolean
  }

  export type VideoRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VideoRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VideoRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoRoom"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      roomId: string
      roomLink: string
    }, ExtArgs["result"]["videoRoom"]>
    composites: {}
  }

  type VideoRoomGetPayload<S extends boolean | null | undefined | VideoRoomDefaultArgs> = $Result.GetResult<Prisma.$VideoRoomPayload, S>

  type VideoRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VideoRoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideoRoomCountAggregateInputType | true
    }

  export interface VideoRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoRoom'], meta: { name: 'VideoRoom' } }
    /**
     * Find zero or one VideoRoom that matches the filter.
     * @param {VideoRoomFindUniqueArgs} args - Arguments to find a VideoRoom
     * @example
     * // Get one VideoRoom
     * const videoRoom = await prisma.videoRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VideoRoomFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, VideoRoomFindUniqueArgs<ExtArgs>>
    ): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one VideoRoom that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VideoRoomFindUniqueOrThrowArgs} args - Arguments to find a VideoRoom
     * @example
     * // Get one VideoRoom
     * const videoRoom = await prisma.videoRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VideoRoomFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoRoomFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first VideoRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRoomFindFirstArgs} args - Arguments to find a VideoRoom
     * @example
     * // Get one VideoRoom
     * const videoRoom = await prisma.videoRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VideoRoomFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoRoomFindFirstArgs<ExtArgs>>
    ): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first VideoRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRoomFindFirstOrThrowArgs} args - Arguments to find a VideoRoom
     * @example
     * // Get one VideoRoom
     * const videoRoom = await prisma.videoRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VideoRoomFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoRoomFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more VideoRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoRooms
     * const videoRooms = await prisma.videoRoom.findMany()
     * 
     * // Get first 10 VideoRooms
     * const videoRooms = await prisma.videoRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoRoomWithIdOnly = await prisma.videoRoom.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VideoRoomFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoRoomFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a VideoRoom.
     * @param {VideoRoomCreateArgs} args - Arguments to create a VideoRoom.
     * @example
     * // Create one VideoRoom
     * const VideoRoom = await prisma.videoRoom.create({
     *   data: {
     *     // ... data to create a VideoRoom
     *   }
     * })
     * 
    **/
    create<T extends VideoRoomCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VideoRoomCreateArgs<ExtArgs>>
    ): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many VideoRooms.
     * @param {VideoRoomCreateManyArgs} args - Arguments to create many VideoRooms.
     * @example
     * // Create many VideoRooms
     * const videoRoom = await prisma.videoRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends VideoRoomCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoRoomCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoRooms and returns the data saved in the database.
     * @param {VideoRoomCreateManyAndReturnArgs} args - Arguments to create many VideoRooms.
     * @example
     * // Create many VideoRooms
     * const videoRoom = await prisma.videoRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoRooms and only return the `id`
     * const videoRoomWithIdOnly = await prisma.videoRoom.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends VideoRoomCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoRoomCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a VideoRoom.
     * @param {VideoRoomDeleteArgs} args - Arguments to delete one VideoRoom.
     * @example
     * // Delete one VideoRoom
     * const VideoRoom = await prisma.videoRoom.delete({
     *   where: {
     *     // ... filter to delete one VideoRoom
     *   }
     * })
     * 
    **/
    delete<T extends VideoRoomDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VideoRoomDeleteArgs<ExtArgs>>
    ): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one VideoRoom.
     * @param {VideoRoomUpdateArgs} args - Arguments to update one VideoRoom.
     * @example
     * // Update one VideoRoom
     * const videoRoom = await prisma.videoRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VideoRoomUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VideoRoomUpdateArgs<ExtArgs>>
    ): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more VideoRooms.
     * @param {VideoRoomDeleteManyArgs} args - Arguments to filter VideoRooms to delete.
     * @example
     * // Delete a few VideoRooms
     * const { count } = await prisma.videoRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VideoRoomDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoRoomDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoRooms
     * const videoRoom = await prisma.videoRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VideoRoomUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VideoRoomUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VideoRoom.
     * @param {VideoRoomUpsertArgs} args - Arguments to update or create a VideoRoom.
     * @example
     * // Update or create a VideoRoom
     * const videoRoom = await prisma.videoRoom.upsert({
     *   create: {
     *     // ... data to create a VideoRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoRoom we want to update
     *   }
     * })
    **/
    upsert<T extends VideoRoomUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VideoRoomUpsertArgs<ExtArgs>>
    ): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of VideoRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRoomCountArgs} args - Arguments to filter VideoRooms to count.
     * @example
     * // Count the number of VideoRooms
     * const count = await prisma.videoRoom.count({
     *   where: {
     *     // ... the filter for the VideoRooms we want to count
     *   }
     * })
    **/
    count<T extends VideoRoomCountArgs>(
      args?: Subset<T, VideoRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoRoomAggregateArgs>(args: Subset<T, VideoRoomAggregateArgs>): Prisma.PrismaPromise<GetVideoRoomAggregateType<T>>

    /**
     * Group by VideoRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoRoomGroupByArgs['orderBy'] }
        : { orderBy?: VideoRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoRoom model
   */
  readonly fields: VideoRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the VideoRoom model
   */ 
  interface VideoRoomFieldRefs {
    readonly id: FieldRef<"VideoRoom", 'String'>
    readonly ownerId: FieldRef<"VideoRoom", 'String'>
    readonly roomId: FieldRef<"VideoRoom", 'String'>
    readonly roomLink: FieldRef<"VideoRoom", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VideoRoom findUnique
   */
  export type VideoRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * Filter, which VideoRoom to fetch.
     */
    where: VideoRoomWhereUniqueInput
  }

  /**
   * VideoRoom findUniqueOrThrow
   */
  export type VideoRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * Filter, which VideoRoom to fetch.
     */
    where: VideoRoomWhereUniqueInput
  }

  /**
   * VideoRoom findFirst
   */
  export type VideoRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * Filter, which VideoRoom to fetch.
     */
    where?: VideoRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoRooms to fetch.
     */
    orderBy?: VideoRoomOrderByWithRelationInput | VideoRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoRooms.
     */
    cursor?: VideoRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoRooms.
     */
    distinct?: VideoRoomScalarFieldEnum | VideoRoomScalarFieldEnum[]
  }

  /**
   * VideoRoom findFirstOrThrow
   */
  export type VideoRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * Filter, which VideoRoom to fetch.
     */
    where?: VideoRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoRooms to fetch.
     */
    orderBy?: VideoRoomOrderByWithRelationInput | VideoRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoRooms.
     */
    cursor?: VideoRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoRooms.
     */
    distinct?: VideoRoomScalarFieldEnum | VideoRoomScalarFieldEnum[]
  }

  /**
   * VideoRoom findMany
   */
  export type VideoRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * Filter, which VideoRooms to fetch.
     */
    where?: VideoRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoRooms to fetch.
     */
    orderBy?: VideoRoomOrderByWithRelationInput | VideoRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoRooms.
     */
    cursor?: VideoRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoRooms.
     */
    skip?: number
    distinct?: VideoRoomScalarFieldEnum | VideoRoomScalarFieldEnum[]
  }

  /**
   * VideoRoom create
   */
  export type VideoRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoRoom.
     */
    data: XOR<VideoRoomCreateInput, VideoRoomUncheckedCreateInput>
  }

  /**
   * VideoRoom createMany
   */
  export type VideoRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoRooms.
     */
    data: VideoRoomCreateManyInput | VideoRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoRoom createManyAndReturn
   */
  export type VideoRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VideoRooms.
     */
    data: VideoRoomCreateManyInput | VideoRoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoRoom update
   */
  export type VideoRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoRoom.
     */
    data: XOR<VideoRoomUpdateInput, VideoRoomUncheckedUpdateInput>
    /**
     * Choose, which VideoRoom to update.
     */
    where: VideoRoomWhereUniqueInput
  }

  /**
   * VideoRoom updateMany
   */
  export type VideoRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoRooms.
     */
    data: XOR<VideoRoomUpdateManyMutationInput, VideoRoomUncheckedUpdateManyInput>
    /**
     * Filter which VideoRooms to update
     */
    where?: VideoRoomWhereInput
  }

  /**
   * VideoRoom upsert
   */
  export type VideoRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoRoom to update in case it exists.
     */
    where: VideoRoomWhereUniqueInput
    /**
     * In case the VideoRoom found by the `where` argument doesn't exist, create a new VideoRoom with this data.
     */
    create: XOR<VideoRoomCreateInput, VideoRoomUncheckedCreateInput>
    /**
     * In case the VideoRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoRoomUpdateInput, VideoRoomUncheckedUpdateInput>
  }

  /**
   * VideoRoom delete
   */
  export type VideoRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * Filter which VideoRoom to delete.
     */
    where: VideoRoomWhereUniqueInput
  }

  /**
   * VideoRoom deleteMany
   */
  export type VideoRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoRooms to delete
     */
    where?: VideoRoomWhereInput
  }

  /**
   * VideoRoom without action
   */
  export type VideoRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    roomId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    roomId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    roomId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    roomId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    roomId: string
    createdAt: Date
    updatedAt: Date
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectScalar = {
    id?: boolean
    roomId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      messages: Prisma.$MessagePayload<ExtArgs>[]
      room: Prisma.$RoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChatFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>
    ): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChatFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>
    ): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChatFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
    **/
    create<T extends ChatCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ChatCreateArgs<ExtArgs>>
    ): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ChatCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {ChatCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ChatCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ChatCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
    **/
    delete<T extends ChatDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>
    ): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChatUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>
    ): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChatDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChatUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
    **/
    upsert<T extends ChatUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>
    ): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    messages<T extends Chat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Chat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Chat model
   */ 
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly roomId: FieldRef<"Chat", 'String'>
    readonly createdAt: FieldRef<"Chat", 'DateTime'>
    readonly updatedAt: FieldRef<"Chat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat createManyAndReturn
   */
  export type ChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
  }

  /**
   * Chat.messages
   */
  export type Chat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    userId: string | null
    chatId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    userId: string | null
    chatId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    userId: number
    chatId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    chatId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    chatId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    chatId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    content: string
    userId: string
    chatId: string
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    userId?: boolean
    chatId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    userId?: boolean
    chatId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    userId?: boolean
    chatId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      chat: Prisma.$ChatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      userId: string
      chatId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageCreateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends MessageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly userId: FieldRef<"Message", 'String'>
    readonly chatId: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model EmailToken
   */

  export type AggregateEmailToken = {
    _count: EmailTokenCountAggregateOutputType | null
    _avg: EmailTokenAvgAggregateOutputType | null
    _sum: EmailTokenSumAggregateOutputType | null
    _min: EmailTokenMinAggregateOutputType | null
    _max: EmailTokenMaxAggregateOutputType | null
  }

  export type EmailTokenAvgAggregateOutputType = {
    attempts: number | null
  }

  export type EmailTokenSumAggregateOutputType = {
    attempts: number | null
  }

  export type EmailTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    validated: boolean | null
    attempts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    validated: boolean | null
    attempts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    validated: number
    attempts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailTokenAvgAggregateInputType = {
    attempts?: true
  }

  export type EmailTokenSumAggregateInputType = {
    attempts?: true
  }

  export type EmailTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    validated?: true
    attempts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    validated?: true
    attempts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    validated?: true
    attempts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailToken to aggregate.
     */
    where?: EmailTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTokens to fetch.
     */
    orderBy?: EmailTokenOrderByWithRelationInput | EmailTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTokens
    **/
    _count?: true | EmailTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTokenMaxAggregateInputType
  }

  export type GetEmailTokenAggregateType<T extends EmailTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailToken[P]>
      : GetScalarType<T[P], AggregateEmailToken[P]>
  }




  export type EmailTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTokenWhereInput
    orderBy?: EmailTokenOrderByWithAggregationInput | EmailTokenOrderByWithAggregationInput[]
    by: EmailTokenScalarFieldEnum[] | EmailTokenScalarFieldEnum
    having?: EmailTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTokenCountAggregateInputType | true
    _avg?: EmailTokenAvgAggregateInputType
    _sum?: EmailTokenSumAggregateInputType
    _min?: EmailTokenMinAggregateInputType
    _max?: EmailTokenMaxAggregateInputType
  }

  export type EmailTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    validated: boolean
    attempts: number
    createdAt: Date
    updatedAt: Date
    _count: EmailTokenCountAggregateOutputType | null
    _avg: EmailTokenAvgAggregateOutputType | null
    _sum: EmailTokenSumAggregateOutputType | null
    _min: EmailTokenMinAggregateOutputType | null
    _max: EmailTokenMaxAggregateOutputType | null
  }

  type GetEmailTokenGroupByPayload<T extends EmailTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTokenGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTokenGroupByOutputType[P]>
        }
      >
    >


  export type EmailTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    validated?: boolean
    attempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailToken"]>

  export type EmailTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    validated?: boolean
    attempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailToken"]>

  export type EmailTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    validated?: boolean
    attempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      validated: boolean
      attempts: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailToken"]>
    composites: {}
  }

  type EmailTokenGetPayload<S extends boolean | null | undefined | EmailTokenDefaultArgs> = $Result.GetResult<Prisma.$EmailTokenPayload, S>

  type EmailTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailTokenCountAggregateInputType | true
    }

  export interface EmailTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailToken'], meta: { name: 'EmailToken' } }
    /**
     * Find zero or one EmailToken that matches the filter.
     * @param {EmailTokenFindUniqueArgs} args - Arguments to find a EmailToken
     * @example
     * // Get one EmailToken
     * const emailToken = await prisma.emailToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailTokenClient<$Result.GetResult<Prisma.$EmailTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailTokenFindUniqueOrThrowArgs} args - Arguments to find a EmailToken
     * @example
     * // Get one EmailToken
     * const emailToken = await prisma.emailToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailTokenClient<$Result.GetResult<Prisma.$EmailTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTokenFindFirstArgs} args - Arguments to find a EmailToken
     * @example
     * // Get one EmailToken
     * const emailToken = await prisma.emailToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTokenFindFirstArgs<ExtArgs>>
    ): Prisma__EmailTokenClient<$Result.GetResult<Prisma.$EmailTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTokenFindFirstOrThrowArgs} args - Arguments to find a EmailToken
     * @example
     * // Get one EmailToken
     * const emailToken = await prisma.emailToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailTokenClient<$Result.GetResult<Prisma.$EmailTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTokens
     * const emailTokens = await prisma.emailToken.findMany()
     * 
     * // Get first 10 EmailTokens
     * const emailTokens = await prisma.emailToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTokenWithIdOnly = await prisma.emailToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailToken.
     * @param {EmailTokenCreateArgs} args - Arguments to create a EmailToken.
     * @example
     * // Create one EmailToken
     * const EmailToken = await prisma.emailToken.create({
     *   data: {
     *     // ... data to create a EmailToken
     *   }
     * })
     * 
    **/
    create<T extends EmailTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTokenCreateArgs<ExtArgs>>
    ): Prisma__EmailTokenClient<$Result.GetResult<Prisma.$EmailTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailTokens.
     * @param {EmailTokenCreateManyArgs} args - Arguments to create many EmailTokens.
     * @example
     * // Create many EmailTokens
     * const emailToken = await prisma.emailToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends EmailTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTokens and returns the data saved in the database.
     * @param {EmailTokenCreateManyAndReturnArgs} args - Arguments to create many EmailTokens.
     * @example
     * // Create many EmailTokens
     * const emailToken = await prisma.emailToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTokens and only return the `id`
     * const emailTokenWithIdOnly = await prisma.emailToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends EmailTokenCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTokenCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTokenPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a EmailToken.
     * @param {EmailTokenDeleteArgs} args - Arguments to delete one EmailToken.
     * @example
     * // Delete one EmailToken
     * const EmailToken = await prisma.emailToken.delete({
     *   where: {
     *     // ... filter to delete one EmailToken
     *   }
     * })
     * 
    **/
    delete<T extends EmailTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTokenDeleteArgs<ExtArgs>>
    ): Prisma__EmailTokenClient<$Result.GetResult<Prisma.$EmailTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailToken.
     * @param {EmailTokenUpdateArgs} args - Arguments to update one EmailToken.
     * @example
     * // Update one EmailToken
     * const emailToken = await prisma.emailToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTokenUpdateArgs<ExtArgs>>
    ): Prisma__EmailTokenClient<$Result.GetResult<Prisma.$EmailTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailTokens.
     * @param {EmailTokenDeleteManyArgs} args - Arguments to filter EmailTokens to delete.
     * @example
     * // Delete a few EmailTokens
     * const { count } = await prisma.emailToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTokens
     * const emailToken = await prisma.emailToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailToken.
     * @param {EmailTokenUpsertArgs} args - Arguments to update or create a EmailToken.
     * @example
     * // Update or create a EmailToken
     * const emailToken = await prisma.emailToken.upsert({
     *   create: {
     *     // ... data to create a EmailToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailToken we want to update
     *   }
     * })
    **/
    upsert<T extends EmailTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTokenUpsertArgs<ExtArgs>>
    ): Prisma__EmailTokenClient<$Result.GetResult<Prisma.$EmailTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTokenCountArgs} args - Arguments to filter EmailTokens to count.
     * @example
     * // Count the number of EmailTokens
     * const count = await prisma.emailToken.count({
     *   where: {
     *     // ... the filter for the EmailTokens we want to count
     *   }
     * })
    **/
    count<T extends EmailTokenCountArgs>(
      args?: Subset<T, EmailTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTokenAggregateArgs>(args: Subset<T, EmailTokenAggregateArgs>): Prisma.PrismaPromise<GetEmailTokenAggregateType<T>>

    /**
     * Group by EmailToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTokenGroupByArgs['orderBy'] }
        : { orderBy?: EmailTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailToken model
   */
  readonly fields: EmailTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailToken model
   */ 
  interface EmailTokenFieldRefs {
    readonly id: FieldRef<"EmailToken", 'String'>
    readonly email: FieldRef<"EmailToken", 'String'>
    readonly token: FieldRef<"EmailToken", 'String'>
    readonly validated: FieldRef<"EmailToken", 'Boolean'>
    readonly attempts: FieldRef<"EmailToken", 'Int'>
    readonly createdAt: FieldRef<"EmailToken", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailToken findUnique
   */
  export type EmailTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailToken
     */
    select?: EmailTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailToken to fetch.
     */
    where: EmailTokenWhereUniqueInput
  }

  /**
   * EmailToken findUniqueOrThrow
   */
  export type EmailTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailToken
     */
    select?: EmailTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailToken to fetch.
     */
    where: EmailTokenWhereUniqueInput
  }

  /**
   * EmailToken findFirst
   */
  export type EmailTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailToken
     */
    select?: EmailTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailToken to fetch.
     */
    where?: EmailTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTokens to fetch.
     */
    orderBy?: EmailTokenOrderByWithRelationInput | EmailTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTokens.
     */
    cursor?: EmailTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTokens.
     */
    distinct?: EmailTokenScalarFieldEnum | EmailTokenScalarFieldEnum[]
  }

  /**
   * EmailToken findFirstOrThrow
   */
  export type EmailTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailToken
     */
    select?: EmailTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailToken to fetch.
     */
    where?: EmailTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTokens to fetch.
     */
    orderBy?: EmailTokenOrderByWithRelationInput | EmailTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTokens.
     */
    cursor?: EmailTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTokens.
     */
    distinct?: EmailTokenScalarFieldEnum | EmailTokenScalarFieldEnum[]
  }

  /**
   * EmailToken findMany
   */
  export type EmailTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailToken
     */
    select?: EmailTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailTokens to fetch.
     */
    where?: EmailTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTokens to fetch.
     */
    orderBy?: EmailTokenOrderByWithRelationInput | EmailTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTokens.
     */
    cursor?: EmailTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTokens.
     */
    skip?: number
    distinct?: EmailTokenScalarFieldEnum | EmailTokenScalarFieldEnum[]
  }

  /**
   * EmailToken create
   */
  export type EmailTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailToken
     */
    select?: EmailTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailToken.
     */
    data: XOR<EmailTokenCreateInput, EmailTokenUncheckedCreateInput>
  }

  /**
   * EmailToken createMany
   */
  export type EmailTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTokens.
     */
    data: EmailTokenCreateManyInput | EmailTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailToken createManyAndReturn
   */
  export type EmailTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailToken
     */
    select?: EmailTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailTokens.
     */
    data: EmailTokenCreateManyInput | EmailTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailToken update
   */
  export type EmailTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailToken
     */
    select?: EmailTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailToken.
     */
    data: XOR<EmailTokenUpdateInput, EmailTokenUncheckedUpdateInput>
    /**
     * Choose, which EmailToken to update.
     */
    where: EmailTokenWhereUniqueInput
  }

  /**
   * EmailToken updateMany
   */
  export type EmailTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTokens.
     */
    data: XOR<EmailTokenUpdateManyMutationInput, EmailTokenUncheckedUpdateManyInput>
    /**
     * Filter which EmailTokens to update
     */
    where?: EmailTokenWhereInput
  }

  /**
   * EmailToken upsert
   */
  export type EmailTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailToken
     */
    select?: EmailTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailToken to update in case it exists.
     */
    where: EmailTokenWhereUniqueInput
    /**
     * In case the EmailToken found by the `where` argument doesn't exist, create a new EmailToken with this data.
     */
    create: XOR<EmailTokenCreateInput, EmailTokenUncheckedCreateInput>
    /**
     * In case the EmailToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTokenUpdateInput, EmailTokenUncheckedUpdateInput>
  }

  /**
   * EmailToken delete
   */
  export type EmailTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailToken
     */
    select?: EmailTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTokenInclude<ExtArgs> | null
    /**
     * Filter which EmailToken to delete.
     */
    where: EmailTokenWhereUniqueInput
  }

  /**
   * EmailToken deleteMany
   */
  export type EmailTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTokens to delete
     */
    where?: EmailTokenWhereInput
  }

  /**
   * EmailToken without action
   */
  export type EmailTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailToken
     */
    select?: EmailTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTokenInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    senderId: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    senderId: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    senderId: number
    message: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    senderId?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    senderId?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    senderId?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    senderId: string
    message: string
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    senderId?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    senderId?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    senderId?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      senderId: string
      message: string
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly senderId: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model FinancialRegistration
   */

  export type AggregateFinancialRegistration = {
    _count: FinancialRegistrationCountAggregateOutputType | null
    _min: FinancialRegistrationMinAggregateOutputType | null
    _max: FinancialRegistrationMaxAggregateOutputType | null
  }

  export type FinancialRegistrationMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type FinancialRegistrationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type FinancialRegistrationCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type FinancialRegistrationMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FinancialRegistrationMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FinancialRegistrationCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type FinancialRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialRegistration to aggregate.
     */
    where?: FinancialRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialRegistrations to fetch.
     */
    orderBy?: FinancialRegistrationOrderByWithRelationInput | FinancialRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialRegistrations
    **/
    _count?: true | FinancialRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialRegistrationMaxAggregateInputType
  }

  export type GetFinancialRegistrationAggregateType<T extends FinancialRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialRegistration[P]>
      : GetScalarType<T[P], AggregateFinancialRegistration[P]>
  }




  export type FinancialRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialRegistrationWhereInput
    orderBy?: FinancialRegistrationOrderByWithAggregationInput | FinancialRegistrationOrderByWithAggregationInput[]
    by: FinancialRegistrationScalarFieldEnum[] | FinancialRegistrationScalarFieldEnum
    having?: FinancialRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialRegistrationCountAggregateInputType | true
    _min?: FinancialRegistrationMinAggregateInputType
    _max?: FinancialRegistrationMaxAggregateInputType
  }

  export type FinancialRegistrationGroupByOutputType = {
    id: string
    userId: string
    _count: FinancialRegistrationCountAggregateOutputType | null
    _min: FinancialRegistrationMinAggregateOutputType | null
    _max: FinancialRegistrationMaxAggregateOutputType | null
  }

  type GetFinancialRegistrationGroupByPayload<T extends FinancialRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type FinancialRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clients?: boolean | FinancialRegistration$clientsArgs<ExtArgs>
    expenses?: boolean | FinancialRegistration$expensesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    Receivable?: boolean | FinancialRegistration$ReceivableArgs<ExtArgs>
    ExtraExpense?: boolean | FinancialRegistration$ExtraExpenseArgs<ExtArgs>
    _count?: boolean | FinancialRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialRegistration"]>

  export type FinancialRegistrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialRegistration"]>

  export type FinancialRegistrationSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type FinancialRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | FinancialRegistration$clientsArgs<ExtArgs>
    expenses?: boolean | FinancialRegistration$expensesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    Receivable?: boolean | FinancialRegistration$ReceivableArgs<ExtArgs>
    ExtraExpense?: boolean | FinancialRegistration$ExtraExpenseArgs<ExtArgs>
    _count?: boolean | FinancialRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FinancialRegistrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FinancialRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialRegistration"
    objects: {
      clients: Prisma.$ClientPayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      Receivable: Prisma.$ReceivablePayload<ExtArgs>[]
      ExtraExpense: Prisma.$ExtraExpensePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
    }, ExtArgs["result"]["financialRegistration"]>
    composites: {}
  }

  type FinancialRegistrationGetPayload<S extends boolean | null | undefined | FinancialRegistrationDefaultArgs> = $Result.GetResult<Prisma.$FinancialRegistrationPayload, S>

  type FinancialRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FinancialRegistrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FinancialRegistrationCountAggregateInputType | true
    }

  export interface FinancialRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialRegistration'], meta: { name: 'FinancialRegistration' } }
    /**
     * Find zero or one FinancialRegistration that matches the filter.
     * @param {FinancialRegistrationFindUniqueArgs} args - Arguments to find a FinancialRegistration
     * @example
     * // Get one FinancialRegistration
     * const financialRegistration = await prisma.financialRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FinancialRegistrationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FinancialRegistrationFindUniqueArgs<ExtArgs>>
    ): Prisma__FinancialRegistrationClient<$Result.GetResult<Prisma.$FinancialRegistrationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FinancialRegistration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FinancialRegistrationFindUniqueOrThrowArgs} args - Arguments to find a FinancialRegistration
     * @example
     * // Get one FinancialRegistration
     * const financialRegistration = await prisma.financialRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FinancialRegistrationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FinancialRegistrationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FinancialRegistrationClient<$Result.GetResult<Prisma.$FinancialRegistrationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FinancialRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRegistrationFindFirstArgs} args - Arguments to find a FinancialRegistration
     * @example
     * // Get one FinancialRegistration
     * const financialRegistration = await prisma.financialRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FinancialRegistrationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FinancialRegistrationFindFirstArgs<ExtArgs>>
    ): Prisma__FinancialRegistrationClient<$Result.GetResult<Prisma.$FinancialRegistrationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FinancialRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRegistrationFindFirstOrThrowArgs} args - Arguments to find a FinancialRegistration
     * @example
     * // Get one FinancialRegistration
     * const financialRegistration = await prisma.financialRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FinancialRegistrationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FinancialRegistrationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FinancialRegistrationClient<$Result.GetResult<Prisma.$FinancialRegistrationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FinancialRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialRegistrations
     * const financialRegistrations = await prisma.financialRegistration.findMany()
     * 
     * // Get first 10 FinancialRegistrations
     * const financialRegistrations = await prisma.financialRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialRegistrationWithIdOnly = await prisma.financialRegistration.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FinancialRegistrationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FinancialRegistrationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialRegistrationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FinancialRegistration.
     * @param {FinancialRegistrationCreateArgs} args - Arguments to create a FinancialRegistration.
     * @example
     * // Create one FinancialRegistration
     * const FinancialRegistration = await prisma.financialRegistration.create({
     *   data: {
     *     // ... data to create a FinancialRegistration
     *   }
     * })
     * 
    **/
    create<T extends FinancialRegistrationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FinancialRegistrationCreateArgs<ExtArgs>>
    ): Prisma__FinancialRegistrationClient<$Result.GetResult<Prisma.$FinancialRegistrationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FinancialRegistrations.
     * @param {FinancialRegistrationCreateManyArgs} args - Arguments to create many FinancialRegistrations.
     * @example
     * // Create many FinancialRegistrations
     * const financialRegistration = await prisma.financialRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends FinancialRegistrationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FinancialRegistrationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialRegistrations and returns the data saved in the database.
     * @param {FinancialRegistrationCreateManyAndReturnArgs} args - Arguments to create many FinancialRegistrations.
     * @example
     * // Create many FinancialRegistrations
     * const financialRegistration = await prisma.financialRegistration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialRegistrations and only return the `id`
     * const financialRegistrationWithIdOnly = await prisma.financialRegistration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends FinancialRegistrationCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, FinancialRegistrationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialRegistrationPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a FinancialRegistration.
     * @param {FinancialRegistrationDeleteArgs} args - Arguments to delete one FinancialRegistration.
     * @example
     * // Delete one FinancialRegistration
     * const FinancialRegistration = await prisma.financialRegistration.delete({
     *   where: {
     *     // ... filter to delete one FinancialRegistration
     *   }
     * })
     * 
    **/
    delete<T extends FinancialRegistrationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FinancialRegistrationDeleteArgs<ExtArgs>>
    ): Prisma__FinancialRegistrationClient<$Result.GetResult<Prisma.$FinancialRegistrationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FinancialRegistration.
     * @param {FinancialRegistrationUpdateArgs} args - Arguments to update one FinancialRegistration.
     * @example
     * // Update one FinancialRegistration
     * const financialRegistration = await prisma.financialRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FinancialRegistrationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FinancialRegistrationUpdateArgs<ExtArgs>>
    ): Prisma__FinancialRegistrationClient<$Result.GetResult<Prisma.$FinancialRegistrationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FinancialRegistrations.
     * @param {FinancialRegistrationDeleteManyArgs} args - Arguments to filter FinancialRegistrations to delete.
     * @example
     * // Delete a few FinancialRegistrations
     * const { count } = await prisma.financialRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FinancialRegistrationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FinancialRegistrationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialRegistrations
     * const financialRegistration = await prisma.financialRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FinancialRegistrationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FinancialRegistrationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FinancialRegistration.
     * @param {FinancialRegistrationUpsertArgs} args - Arguments to update or create a FinancialRegistration.
     * @example
     * // Update or create a FinancialRegistration
     * const financialRegistration = await prisma.financialRegistration.upsert({
     *   create: {
     *     // ... data to create a FinancialRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialRegistration we want to update
     *   }
     * })
    **/
    upsert<T extends FinancialRegistrationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FinancialRegistrationUpsertArgs<ExtArgs>>
    ): Prisma__FinancialRegistrationClient<$Result.GetResult<Prisma.$FinancialRegistrationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FinancialRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRegistrationCountArgs} args - Arguments to filter FinancialRegistrations to count.
     * @example
     * // Count the number of FinancialRegistrations
     * const count = await prisma.financialRegistration.count({
     *   where: {
     *     // ... the filter for the FinancialRegistrations we want to count
     *   }
     * })
    **/
    count<T extends FinancialRegistrationCountArgs>(
      args?: Subset<T, FinancialRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialRegistrationAggregateArgs>(args: Subset<T, FinancialRegistrationAggregateArgs>): Prisma.PrismaPromise<GetFinancialRegistrationAggregateType<T>>

    /**
     * Group by FinancialRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: FinancialRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialRegistration model
   */
  readonly fields: FinancialRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clients<T extends FinancialRegistration$clientsArgs<ExtArgs> = {}>(args?: Subset<T, FinancialRegistration$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findMany'> | Null>;

    expenses<T extends FinancialRegistration$expensesArgs<ExtArgs> = {}>(args?: Subset<T, FinancialRegistration$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'findMany'> | Null>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Receivable<T extends FinancialRegistration$ReceivableArgs<ExtArgs> = {}>(args?: Subset<T, FinancialRegistration$ReceivableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, 'findMany'> | Null>;

    ExtraExpense<T extends FinancialRegistration$ExtraExpenseArgs<ExtArgs> = {}>(args?: Subset<T, FinancialRegistration$ExtraExpenseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtraExpensePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FinancialRegistration model
   */ 
  interface FinancialRegistrationFieldRefs {
    readonly id: FieldRef<"FinancialRegistration", 'String'>
    readonly userId: FieldRef<"FinancialRegistration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FinancialRegistration findUnique
   */
  export type FinancialRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRegistration
     */
    select?: FinancialRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which FinancialRegistration to fetch.
     */
    where: FinancialRegistrationWhereUniqueInput
  }

  /**
   * FinancialRegistration findUniqueOrThrow
   */
  export type FinancialRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRegistration
     */
    select?: FinancialRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which FinancialRegistration to fetch.
     */
    where: FinancialRegistrationWhereUniqueInput
  }

  /**
   * FinancialRegistration findFirst
   */
  export type FinancialRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRegistration
     */
    select?: FinancialRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which FinancialRegistration to fetch.
     */
    where?: FinancialRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialRegistrations to fetch.
     */
    orderBy?: FinancialRegistrationOrderByWithRelationInput | FinancialRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialRegistrations.
     */
    cursor?: FinancialRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialRegistrations.
     */
    distinct?: FinancialRegistrationScalarFieldEnum | FinancialRegistrationScalarFieldEnum[]
  }

  /**
   * FinancialRegistration findFirstOrThrow
   */
  export type FinancialRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRegistration
     */
    select?: FinancialRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which FinancialRegistration to fetch.
     */
    where?: FinancialRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialRegistrations to fetch.
     */
    orderBy?: FinancialRegistrationOrderByWithRelationInput | FinancialRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialRegistrations.
     */
    cursor?: FinancialRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialRegistrations.
     */
    distinct?: FinancialRegistrationScalarFieldEnum | FinancialRegistrationScalarFieldEnum[]
  }

  /**
   * FinancialRegistration findMany
   */
  export type FinancialRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRegistration
     */
    select?: FinancialRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which FinancialRegistrations to fetch.
     */
    where?: FinancialRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialRegistrations to fetch.
     */
    orderBy?: FinancialRegistrationOrderByWithRelationInput | FinancialRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialRegistrations.
     */
    cursor?: FinancialRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialRegistrations.
     */
    skip?: number
    distinct?: FinancialRegistrationScalarFieldEnum | FinancialRegistrationScalarFieldEnum[]
  }

  /**
   * FinancialRegistration create
   */
  export type FinancialRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRegistration
     */
    select?: FinancialRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialRegistration.
     */
    data: XOR<FinancialRegistrationCreateInput, FinancialRegistrationUncheckedCreateInput>
  }

  /**
   * FinancialRegistration createMany
   */
  export type FinancialRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialRegistrations.
     */
    data: FinancialRegistrationCreateManyInput | FinancialRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancialRegistration createManyAndReturn
   */
  export type FinancialRegistrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRegistration
     */
    select?: FinancialRegistrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FinancialRegistrations.
     */
    data: FinancialRegistrationCreateManyInput | FinancialRegistrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRegistrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialRegistration update
   */
  export type FinancialRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRegistration
     */
    select?: FinancialRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialRegistration.
     */
    data: XOR<FinancialRegistrationUpdateInput, FinancialRegistrationUncheckedUpdateInput>
    /**
     * Choose, which FinancialRegistration to update.
     */
    where: FinancialRegistrationWhereUniqueInput
  }

  /**
   * FinancialRegistration updateMany
   */
  export type FinancialRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialRegistrations.
     */
    data: XOR<FinancialRegistrationUpdateManyMutationInput, FinancialRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which FinancialRegistrations to update
     */
    where?: FinancialRegistrationWhereInput
  }

  /**
   * FinancialRegistration upsert
   */
  export type FinancialRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRegistration
     */
    select?: FinancialRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialRegistration to update in case it exists.
     */
    where: FinancialRegistrationWhereUniqueInput
    /**
     * In case the FinancialRegistration found by the `where` argument doesn't exist, create a new FinancialRegistration with this data.
     */
    create: XOR<FinancialRegistrationCreateInput, FinancialRegistrationUncheckedCreateInput>
    /**
     * In case the FinancialRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialRegistrationUpdateInput, FinancialRegistrationUncheckedUpdateInput>
  }

  /**
   * FinancialRegistration delete
   */
  export type FinancialRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRegistration
     */
    select?: FinancialRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRegistrationInclude<ExtArgs> | null
    /**
     * Filter which FinancialRegistration to delete.
     */
    where: FinancialRegistrationWhereUniqueInput
  }

  /**
   * FinancialRegistration deleteMany
   */
  export type FinancialRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialRegistrations to delete
     */
    where?: FinancialRegistrationWhereInput
  }

  /**
   * FinancialRegistration.clients
   */
  export type FinancialRegistration$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * FinancialRegistration.expenses
   */
  export type FinancialRegistration$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * FinancialRegistration.Receivable
   */
  export type FinancialRegistration$ReceivableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    where?: ReceivableWhereInput
    orderBy?: ReceivableOrderByWithRelationInput | ReceivableOrderByWithRelationInput[]
    cursor?: ReceivableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceivableScalarFieldEnum | ReceivableScalarFieldEnum[]
  }

  /**
   * FinancialRegistration.ExtraExpense
   */
  export type FinancialRegistration$ExtraExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraExpense
     */
    select?: ExtraExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraExpenseInclude<ExtArgs> | null
    where?: ExtraExpenseWhereInput
    orderBy?: ExtraExpenseOrderByWithRelationInput | ExtraExpenseOrderByWithRelationInput[]
    cursor?: ExtraExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExtraExpenseScalarFieldEnum | ExtraExpenseScalarFieldEnum[]
  }

  /**
   * FinancialRegistration without action
   */
  export type FinancialRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRegistration
     */
    select?: FinancialRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ClientType | null
    address: string | null
    phone: string | null
    email: string | null
    financialRegistrationId: string | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ClientType | null
    address: string | null
    phone: string | null
    email: string | null
    financialRegistrationId: string | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    type: number
    address: number
    phone: number
    email: number
    financialRegistrationId: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    address?: true
    phone?: true
    email?: true
    financialRegistrationId?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    address?: true
    phone?: true
    email?: true
    financialRegistrationId?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    address?: true
    phone?: true
    email?: true
    financialRegistrationId?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    name: string
    type: $Enums.ClientType
    address: string
    phone: string
    email: string
    financialRegistrationId: string
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    financialRegistrationId?: boolean
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
    Receivable?: boolean | Client$ReceivableArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    financialRegistrationId?: boolean
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    financialRegistrationId?: boolean
  }

  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
    Receivable?: boolean | Client$ReceivableArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      financialRegistration: Prisma.$FinancialRegistrationPayload<ExtArgs>
      Receivable: Prisma.$ReceivablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.ClientType
      address: string
      phone: string
      email: string
      financialRegistrationId: string
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
    **/
    create<T extends ClientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientCreateArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
    **/
    delete<T extends ClientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
    **/
    upsert<T extends ClientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    financialRegistration<T extends FinancialRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FinancialRegistrationDefaultArgs<ExtArgs>>): Prisma__FinancialRegistrationClient<$Result.GetResult<Prisma.$FinancialRegistrationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Receivable<T extends Client$ReceivableArgs<ExtArgs> = {}>(args?: Subset<T, Client$ReceivableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly type: FieldRef<"Client", 'ClientType'>
    readonly address: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly financialRegistrationId: FieldRef<"Client", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }

  /**
   * Client.Receivable
   */
  export type Client$ReceivableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    where?: ReceivableWhereInput
    orderBy?: ReceivableOrderByWithRelationInput | ReceivableOrderByWithRelationInput[]
    cursor?: ReceivableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceivableScalarFieldEnum | ReceivableScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: number | null
    recurringMonth: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: number | null
    recurringMonth: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    type: $Enums.ExpenseType | null
    amount: number | null
    recurringMonth: number | null
    contractStartDate: Date | null
    contractEndDate: Date | null
    financialRegistrationId: string | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    type: $Enums.ExpenseType | null
    amount: number | null
    recurringMonth: number | null
    contractStartDate: Date | null
    contractEndDate: Date | null
    financialRegistrationId: string | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    type: number
    amount: number
    recurringMonth: number
    contractStartDate: number
    contractEndDate: number
    financialRegistrationId: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
    recurringMonth?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
    recurringMonth?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    recurringMonth?: true
    contractStartDate?: true
    contractEndDate?: true
    financialRegistrationId?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    recurringMonth?: true
    contractStartDate?: true
    contractEndDate?: true
    financialRegistrationId?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    recurringMonth?: true
    contractStartDate?: true
    contractEndDate?: true
    financialRegistrationId?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    type: $Enums.ExpenseType
    amount: number
    recurringMonth: number
    contractStartDate: Date
    contractEndDate: Date | null
    financialRegistrationId: string
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    recurringMonth?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    financialRegistrationId?: boolean
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    recurringMonth?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    financialRegistrationId?: boolean
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    type?: boolean
    amount?: boolean
    recurringMonth?: boolean
    contractStartDate?: boolean
    contractEndDate?: boolean
    financialRegistrationId?: boolean
  }

  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      financialRegistration: Prisma.$FinancialRegistrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.ExpenseType
      amount: number
      recurringMonth: number
      contractStartDate: Date
      contractEndDate: Date | null
      financialRegistrationId: string
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExpenseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExpenseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExpenseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
    **/
    create<T extends ExpenseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ExpenseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
    **/
    delete<T extends ExpenseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExpenseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExpenseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExpenseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
    **/
    upsert<T extends ExpenseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>
    ): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    financialRegistration<T extends FinancialRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FinancialRegistrationDefaultArgs<ExtArgs>>): Prisma__FinancialRegistrationClient<$Result.GetResult<Prisma.$FinancialRegistrationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Expense model
   */ 
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly type: FieldRef<"Expense", 'ExpenseType'>
    readonly amount: FieldRef<"Expense", 'Float'>
    readonly recurringMonth: FieldRef<"Expense", 'Int'>
    readonly contractStartDate: FieldRef<"Expense", 'DateTime'>
    readonly contractEndDate: FieldRef<"Expense", 'DateTime'>
    readonly financialRegistrationId: FieldRef<"Expense", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model Receivable
   */

  export type AggregateReceivable = {
    _count: ReceivableCountAggregateOutputType | null
    _avg: ReceivableAvgAggregateOutputType | null
    _sum: ReceivableSumAggregateOutputType | null
    _min: ReceivableMinAggregateOutputType | null
    _max: ReceivableMaxAggregateOutputType | null
  }

  export type ReceivableAvgAggregateOutputType = {
    amountToReceive: number | null
  }

  export type ReceivableSumAggregateOutputType = {
    amountToReceive: number | null
  }

  export type ReceivableMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    serviceProvided: string | null
    amountToReceive: number | null
    serviceStartDate: Date | null
    serviceEndDate: Date | null
    financialRegistrationId: string | null
  }

  export type ReceivableMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    serviceProvided: string | null
    amountToReceive: number | null
    serviceStartDate: Date | null
    serviceEndDate: Date | null
    financialRegistrationId: string | null
  }

  export type ReceivableCountAggregateOutputType = {
    id: number
    clientId: number
    serviceProvided: number
    amountToReceive: number
    serviceStartDate: number
    serviceEndDate: number
    financialRegistrationId: number
    _all: number
  }


  export type ReceivableAvgAggregateInputType = {
    amountToReceive?: true
  }

  export type ReceivableSumAggregateInputType = {
    amountToReceive?: true
  }

  export type ReceivableMinAggregateInputType = {
    id?: true
    clientId?: true
    serviceProvided?: true
    amountToReceive?: true
    serviceStartDate?: true
    serviceEndDate?: true
    financialRegistrationId?: true
  }

  export type ReceivableMaxAggregateInputType = {
    id?: true
    clientId?: true
    serviceProvided?: true
    amountToReceive?: true
    serviceStartDate?: true
    serviceEndDate?: true
    financialRegistrationId?: true
  }

  export type ReceivableCountAggregateInputType = {
    id?: true
    clientId?: true
    serviceProvided?: true
    amountToReceive?: true
    serviceStartDate?: true
    serviceEndDate?: true
    financialRegistrationId?: true
    _all?: true
  }

  export type ReceivableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receivable to aggregate.
     */
    where?: ReceivableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivables to fetch.
     */
    orderBy?: ReceivableOrderByWithRelationInput | ReceivableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceivableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Receivables
    **/
    _count?: true | ReceivableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceivableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceivableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceivableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceivableMaxAggregateInputType
  }

  export type GetReceivableAggregateType<T extends ReceivableAggregateArgs> = {
        [P in keyof T & keyof AggregateReceivable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceivable[P]>
      : GetScalarType<T[P], AggregateReceivable[P]>
  }




  export type ReceivableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivableWhereInput
    orderBy?: ReceivableOrderByWithAggregationInput | ReceivableOrderByWithAggregationInput[]
    by: ReceivableScalarFieldEnum[] | ReceivableScalarFieldEnum
    having?: ReceivableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceivableCountAggregateInputType | true
    _avg?: ReceivableAvgAggregateInputType
    _sum?: ReceivableSumAggregateInputType
    _min?: ReceivableMinAggregateInputType
    _max?: ReceivableMaxAggregateInputType
  }

  export type ReceivableGroupByOutputType = {
    id: string
    clientId: string
    serviceProvided: string
    amountToReceive: number
    serviceStartDate: Date
    serviceEndDate: Date
    financialRegistrationId: string
    _count: ReceivableCountAggregateOutputType | null
    _avg: ReceivableAvgAggregateOutputType | null
    _sum: ReceivableSumAggregateOutputType | null
    _min: ReceivableMinAggregateOutputType | null
    _max: ReceivableMaxAggregateOutputType | null
  }

  type GetReceivableGroupByPayload<T extends ReceivableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceivableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceivableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceivableGroupByOutputType[P]>
            : GetScalarType<T[P], ReceivableGroupByOutputType[P]>
        }
      >
    >


  export type ReceivableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    serviceProvided?: boolean
    amountToReceive?: boolean
    serviceStartDate?: boolean
    serviceEndDate?: boolean
    financialRegistrationId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receivable"]>

  export type ReceivableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    serviceProvided?: boolean
    amountToReceive?: boolean
    serviceStartDate?: boolean
    serviceEndDate?: boolean
    financialRegistrationId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receivable"]>

  export type ReceivableSelectScalar = {
    id?: boolean
    clientId?: boolean
    serviceProvided?: boolean
    amountToReceive?: boolean
    serviceStartDate?: boolean
    serviceEndDate?: boolean
    financialRegistrationId?: boolean
  }

  export type ReceivableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
  }
  export type ReceivableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
  }

  export type $ReceivablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Receivable"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      financialRegistration: Prisma.$FinancialRegistrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      serviceProvided: string
      amountToReceive: number
      serviceStartDate: Date
      serviceEndDate: Date
      financialRegistrationId: string
    }, ExtArgs["result"]["receivable"]>
    composites: {}
  }

  type ReceivableGetPayload<S extends boolean | null | undefined | ReceivableDefaultArgs> = $Result.GetResult<Prisma.$ReceivablePayload, S>

  type ReceivableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReceivableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReceivableCountAggregateInputType | true
    }

  export interface ReceivableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Receivable'], meta: { name: 'Receivable' } }
    /**
     * Find zero or one Receivable that matches the filter.
     * @param {ReceivableFindUniqueArgs} args - Arguments to find a Receivable
     * @example
     * // Get one Receivable
     * const receivable = await prisma.receivable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReceivableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReceivableFindUniqueArgs<ExtArgs>>
    ): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Receivable that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReceivableFindUniqueOrThrowArgs} args - Arguments to find a Receivable
     * @example
     * // Get one Receivable
     * const receivable = await prisma.receivable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReceivableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceivableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Receivable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableFindFirstArgs} args - Arguments to find a Receivable
     * @example
     * // Get one Receivable
     * const receivable = await prisma.receivable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReceivableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceivableFindFirstArgs<ExtArgs>>
    ): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Receivable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableFindFirstOrThrowArgs} args - Arguments to find a Receivable
     * @example
     * // Get one Receivable
     * const receivable = await prisma.receivable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReceivableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceivableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Receivables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receivables
     * const receivables = await prisma.receivable.findMany()
     * 
     * // Get first 10 Receivables
     * const receivables = await prisma.receivable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receivableWithIdOnly = await prisma.receivable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReceivableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceivableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Receivable.
     * @param {ReceivableCreateArgs} args - Arguments to create a Receivable.
     * @example
     * // Create one Receivable
     * const Receivable = await prisma.receivable.create({
     *   data: {
     *     // ... data to create a Receivable
     *   }
     * })
     * 
    **/
    create<T extends ReceivableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReceivableCreateArgs<ExtArgs>>
    ): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Receivables.
     * @param {ReceivableCreateManyArgs} args - Arguments to create many Receivables.
     * @example
     * // Create many Receivables
     * const receivable = await prisma.receivable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ReceivableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceivableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Receivables and returns the data saved in the database.
     * @param {ReceivableCreateManyAndReturnArgs} args - Arguments to create many Receivables.
     * @example
     * // Create many Receivables
     * const receivable = await prisma.receivable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Receivables and only return the `id`
     * const receivableWithIdOnly = await prisma.receivable.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ReceivableCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceivableCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Receivable.
     * @param {ReceivableDeleteArgs} args - Arguments to delete one Receivable.
     * @example
     * // Delete one Receivable
     * const Receivable = await prisma.receivable.delete({
     *   where: {
     *     // ... filter to delete one Receivable
     *   }
     * })
     * 
    **/
    delete<T extends ReceivableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReceivableDeleteArgs<ExtArgs>>
    ): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Receivable.
     * @param {ReceivableUpdateArgs} args - Arguments to update one Receivable.
     * @example
     * // Update one Receivable
     * const receivable = await prisma.receivable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReceivableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReceivableUpdateArgs<ExtArgs>>
    ): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Receivables.
     * @param {ReceivableDeleteManyArgs} args - Arguments to filter Receivables to delete.
     * @example
     * // Delete a few Receivables
     * const { count } = await prisma.receivable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReceivableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceivableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receivables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receivables
     * const receivable = await prisma.receivable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReceivableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReceivableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Receivable.
     * @param {ReceivableUpsertArgs} args - Arguments to update or create a Receivable.
     * @example
     * // Update or create a Receivable
     * const receivable = await prisma.receivable.upsert({
     *   create: {
     *     // ... data to create a Receivable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receivable we want to update
     *   }
     * })
    **/
    upsert<T extends ReceivableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReceivableUpsertArgs<ExtArgs>>
    ): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Receivables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableCountArgs} args - Arguments to filter Receivables to count.
     * @example
     * // Count the number of Receivables
     * const count = await prisma.receivable.count({
     *   where: {
     *     // ... the filter for the Receivables we want to count
     *   }
     * })
    **/
    count<T extends ReceivableCountArgs>(
      args?: Subset<T, ReceivableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceivableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receivable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceivableAggregateArgs>(args: Subset<T, ReceivableAggregateArgs>): Prisma.PrismaPromise<GetReceivableAggregateType<T>>

    /**
     * Group by Receivable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceivableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceivableGroupByArgs['orderBy'] }
        : { orderBy?: ReceivableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceivableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceivableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Receivable model
   */
  readonly fields: ReceivableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Receivable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceivableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    financialRegistration<T extends FinancialRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FinancialRegistrationDefaultArgs<ExtArgs>>): Prisma__FinancialRegistrationClient<$Result.GetResult<Prisma.$FinancialRegistrationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Receivable model
   */ 
  interface ReceivableFieldRefs {
    readonly id: FieldRef<"Receivable", 'String'>
    readonly clientId: FieldRef<"Receivable", 'String'>
    readonly serviceProvided: FieldRef<"Receivable", 'String'>
    readonly amountToReceive: FieldRef<"Receivable", 'Float'>
    readonly serviceStartDate: FieldRef<"Receivable", 'DateTime'>
    readonly serviceEndDate: FieldRef<"Receivable", 'DateTime'>
    readonly financialRegistrationId: FieldRef<"Receivable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Receivable findUnique
   */
  export type ReceivableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * Filter, which Receivable to fetch.
     */
    where: ReceivableWhereUniqueInput
  }

  /**
   * Receivable findUniqueOrThrow
   */
  export type ReceivableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * Filter, which Receivable to fetch.
     */
    where: ReceivableWhereUniqueInput
  }

  /**
   * Receivable findFirst
   */
  export type ReceivableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * Filter, which Receivable to fetch.
     */
    where?: ReceivableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivables to fetch.
     */
    orderBy?: ReceivableOrderByWithRelationInput | ReceivableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receivables.
     */
    cursor?: ReceivableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receivables.
     */
    distinct?: ReceivableScalarFieldEnum | ReceivableScalarFieldEnum[]
  }

  /**
   * Receivable findFirstOrThrow
   */
  export type ReceivableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * Filter, which Receivable to fetch.
     */
    where?: ReceivableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivables to fetch.
     */
    orderBy?: ReceivableOrderByWithRelationInput | ReceivableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receivables.
     */
    cursor?: ReceivableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receivables.
     */
    distinct?: ReceivableScalarFieldEnum | ReceivableScalarFieldEnum[]
  }

  /**
   * Receivable findMany
   */
  export type ReceivableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * Filter, which Receivables to fetch.
     */
    where?: ReceivableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivables to fetch.
     */
    orderBy?: ReceivableOrderByWithRelationInput | ReceivableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Receivables.
     */
    cursor?: ReceivableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivables.
     */
    skip?: number
    distinct?: ReceivableScalarFieldEnum | ReceivableScalarFieldEnum[]
  }

  /**
   * Receivable create
   */
  export type ReceivableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * The data needed to create a Receivable.
     */
    data: XOR<ReceivableCreateInput, ReceivableUncheckedCreateInput>
  }

  /**
   * Receivable createMany
   */
  export type ReceivableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Receivables.
     */
    data: ReceivableCreateManyInput | ReceivableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Receivable createManyAndReturn
   */
  export type ReceivableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Receivables.
     */
    data: ReceivableCreateManyInput | ReceivableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Receivable update
   */
  export type ReceivableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * The data needed to update a Receivable.
     */
    data: XOR<ReceivableUpdateInput, ReceivableUncheckedUpdateInput>
    /**
     * Choose, which Receivable to update.
     */
    where: ReceivableWhereUniqueInput
  }

  /**
   * Receivable updateMany
   */
  export type ReceivableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Receivables.
     */
    data: XOR<ReceivableUpdateManyMutationInput, ReceivableUncheckedUpdateManyInput>
    /**
     * Filter which Receivables to update
     */
    where?: ReceivableWhereInput
  }

  /**
   * Receivable upsert
   */
  export type ReceivableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * The filter to search for the Receivable to update in case it exists.
     */
    where: ReceivableWhereUniqueInput
    /**
     * In case the Receivable found by the `where` argument doesn't exist, create a new Receivable with this data.
     */
    create: XOR<ReceivableCreateInput, ReceivableUncheckedCreateInput>
    /**
     * In case the Receivable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceivableUpdateInput, ReceivableUncheckedUpdateInput>
  }

  /**
   * Receivable delete
   */
  export type ReceivableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * Filter which Receivable to delete.
     */
    where: ReceivableWhereUniqueInput
  }

  /**
   * Receivable deleteMany
   */
  export type ReceivableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receivables to delete
     */
    where?: ReceivableWhereInput
  }

  /**
   * Receivable without action
   */
  export type ReceivableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
  }


  /**
   * Model ExtraExpense
   */

  export type AggregateExtraExpense = {
    _count: ExtraExpenseCountAggregateOutputType | null
    _avg: ExtraExpenseAvgAggregateOutputType | null
    _sum: ExtraExpenseSumAggregateOutputType | null
    _min: ExtraExpenseMinAggregateOutputType | null
    _max: ExtraExpenseMaxAggregateOutputType | null
  }

  export type ExtraExpenseAvgAggregateOutputType = {
    amount: number | null
  }

  export type ExtraExpenseSumAggregateOutputType = {
    amount: number | null
  }

  export type ExtraExpenseMinAggregateOutputType = {
    id: string | null
    expenseType: string | null
    amount: number | null
    startDate: Date | null
    endDate: Date | null
    financialRegistrationId: string | null
  }

  export type ExtraExpenseMaxAggregateOutputType = {
    id: string | null
    expenseType: string | null
    amount: number | null
    startDate: Date | null
    endDate: Date | null
    financialRegistrationId: string | null
  }

  export type ExtraExpenseCountAggregateOutputType = {
    id: number
    expenseType: number
    amount: number
    startDate: number
    endDate: number
    financialRegistrationId: number
    _all: number
  }


  export type ExtraExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type ExtraExpenseSumAggregateInputType = {
    amount?: true
  }

  export type ExtraExpenseMinAggregateInputType = {
    id?: true
    expenseType?: true
    amount?: true
    startDate?: true
    endDate?: true
    financialRegistrationId?: true
  }

  export type ExtraExpenseMaxAggregateInputType = {
    id?: true
    expenseType?: true
    amount?: true
    startDate?: true
    endDate?: true
    financialRegistrationId?: true
  }

  export type ExtraExpenseCountAggregateInputType = {
    id?: true
    expenseType?: true
    amount?: true
    startDate?: true
    endDate?: true
    financialRegistrationId?: true
    _all?: true
  }

  export type ExtraExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExtraExpense to aggregate.
     */
    where?: ExtraExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtraExpenses to fetch.
     */
    orderBy?: ExtraExpenseOrderByWithRelationInput | ExtraExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExtraExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtraExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtraExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExtraExpenses
    **/
    _count?: true | ExtraExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExtraExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExtraExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExtraExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExtraExpenseMaxAggregateInputType
  }

  export type GetExtraExpenseAggregateType<T extends ExtraExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExtraExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtraExpense[P]>
      : GetScalarType<T[P], AggregateExtraExpense[P]>
  }




  export type ExtraExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExtraExpenseWhereInput
    orderBy?: ExtraExpenseOrderByWithAggregationInput | ExtraExpenseOrderByWithAggregationInput[]
    by: ExtraExpenseScalarFieldEnum[] | ExtraExpenseScalarFieldEnum
    having?: ExtraExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExtraExpenseCountAggregateInputType | true
    _avg?: ExtraExpenseAvgAggregateInputType
    _sum?: ExtraExpenseSumAggregateInputType
    _min?: ExtraExpenseMinAggregateInputType
    _max?: ExtraExpenseMaxAggregateInputType
  }

  export type ExtraExpenseGroupByOutputType = {
    id: string
    expenseType: string
    amount: number
    startDate: Date
    endDate: Date
    financialRegistrationId: string
    _count: ExtraExpenseCountAggregateOutputType | null
    _avg: ExtraExpenseAvgAggregateOutputType | null
    _sum: ExtraExpenseSumAggregateOutputType | null
    _min: ExtraExpenseMinAggregateOutputType | null
    _max: ExtraExpenseMaxAggregateOutputType | null
  }

  type GetExtraExpenseGroupByPayload<T extends ExtraExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExtraExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExtraExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExtraExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExtraExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExtraExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseType?: boolean
    amount?: boolean
    startDate?: boolean
    endDate?: boolean
    financialRegistrationId?: boolean
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["extraExpense"]>

  export type ExtraExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseType?: boolean
    amount?: boolean
    startDate?: boolean
    endDate?: boolean
    financialRegistrationId?: boolean
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["extraExpense"]>

  export type ExtraExpenseSelectScalar = {
    id?: boolean
    expenseType?: boolean
    amount?: boolean
    startDate?: boolean
    endDate?: boolean
    financialRegistrationId?: boolean
  }

  export type ExtraExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
  }
  export type ExtraExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    financialRegistration?: boolean | FinancialRegistrationDefaultArgs<ExtArgs>
  }

  export type $ExtraExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExtraExpense"
    objects: {
      financialRegistration: Prisma.$FinancialRegistrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expenseType: string
      amount: number
      startDate: Date
      endDate: Date
      financialRegistrationId: string
    }, ExtArgs["result"]["extraExpense"]>
    composites: {}
  }

  type ExtraExpenseGetPayload<S extends boolean | null | undefined | ExtraExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExtraExpensePayload, S>

  type ExtraExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExtraExpenseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExtraExpenseCountAggregateInputType | true
    }

  export interface ExtraExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExtraExpense'], meta: { name: 'ExtraExpense' } }
    /**
     * Find zero or one ExtraExpense that matches the filter.
     * @param {ExtraExpenseFindUniqueArgs} args - Arguments to find a ExtraExpense
     * @example
     * // Get one ExtraExpense
     * const extraExpense = await prisma.extraExpense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExtraExpenseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ExtraExpenseFindUniqueArgs<ExtArgs>>
    ): Prisma__ExtraExpenseClient<$Result.GetResult<Prisma.$ExtraExpensePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ExtraExpense that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExtraExpenseFindUniqueOrThrowArgs} args - Arguments to find a ExtraExpense
     * @example
     * // Get one ExtraExpense
     * const extraExpense = await prisma.extraExpense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExtraExpenseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExtraExpenseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ExtraExpenseClient<$Result.GetResult<Prisma.$ExtraExpensePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ExtraExpense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraExpenseFindFirstArgs} args - Arguments to find a ExtraExpense
     * @example
     * // Get one ExtraExpense
     * const extraExpense = await prisma.extraExpense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExtraExpenseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ExtraExpenseFindFirstArgs<ExtArgs>>
    ): Prisma__ExtraExpenseClient<$Result.GetResult<Prisma.$ExtraExpensePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ExtraExpense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraExpenseFindFirstOrThrowArgs} args - Arguments to find a ExtraExpense
     * @example
     * // Get one ExtraExpense
     * const extraExpense = await prisma.extraExpense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExtraExpenseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExtraExpenseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ExtraExpenseClient<$Result.GetResult<Prisma.$ExtraExpensePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ExtraExpenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExtraExpenses
     * const extraExpenses = await prisma.extraExpense.findMany()
     * 
     * // Get first 10 ExtraExpenses
     * const extraExpenses = await prisma.extraExpense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const extraExpenseWithIdOnly = await prisma.extraExpense.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExtraExpenseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExtraExpenseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtraExpensePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ExtraExpense.
     * @param {ExtraExpenseCreateArgs} args - Arguments to create a ExtraExpense.
     * @example
     * // Create one ExtraExpense
     * const ExtraExpense = await prisma.extraExpense.create({
     *   data: {
     *     // ... data to create a ExtraExpense
     *   }
     * })
     * 
    **/
    create<T extends ExtraExpenseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ExtraExpenseCreateArgs<ExtArgs>>
    ): Prisma__ExtraExpenseClient<$Result.GetResult<Prisma.$ExtraExpensePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ExtraExpenses.
     * @param {ExtraExpenseCreateManyArgs} args - Arguments to create many ExtraExpenses.
     * @example
     * // Create many ExtraExpenses
     * const extraExpense = await prisma.extraExpense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ExtraExpenseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExtraExpenseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExtraExpenses and returns the data saved in the database.
     * @param {ExtraExpenseCreateManyAndReturnArgs} args - Arguments to create many ExtraExpenses.
     * @example
     * // Create many ExtraExpenses
     * const extraExpense = await prisma.extraExpense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExtraExpenses and only return the `id`
     * const extraExpenseWithIdOnly = await prisma.extraExpense.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ExtraExpenseCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ExtraExpenseCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtraExpensePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a ExtraExpense.
     * @param {ExtraExpenseDeleteArgs} args - Arguments to delete one ExtraExpense.
     * @example
     * // Delete one ExtraExpense
     * const ExtraExpense = await prisma.extraExpense.delete({
     *   where: {
     *     // ... filter to delete one ExtraExpense
     *   }
     * })
     * 
    **/
    delete<T extends ExtraExpenseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ExtraExpenseDeleteArgs<ExtArgs>>
    ): Prisma__ExtraExpenseClient<$Result.GetResult<Prisma.$ExtraExpensePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ExtraExpense.
     * @param {ExtraExpenseUpdateArgs} args - Arguments to update one ExtraExpense.
     * @example
     * // Update one ExtraExpense
     * const extraExpense = await prisma.extraExpense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExtraExpenseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ExtraExpenseUpdateArgs<ExtArgs>>
    ): Prisma__ExtraExpenseClient<$Result.GetResult<Prisma.$ExtraExpensePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ExtraExpenses.
     * @param {ExtraExpenseDeleteManyArgs} args - Arguments to filter ExtraExpenses to delete.
     * @example
     * // Delete a few ExtraExpenses
     * const { count } = await prisma.extraExpense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExtraExpenseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExtraExpenseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExtraExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExtraExpenses
     * const extraExpense = await prisma.extraExpense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExtraExpenseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ExtraExpenseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExtraExpense.
     * @param {ExtraExpenseUpsertArgs} args - Arguments to update or create a ExtraExpense.
     * @example
     * // Update or create a ExtraExpense
     * const extraExpense = await prisma.extraExpense.upsert({
     *   create: {
     *     // ... data to create a ExtraExpense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExtraExpense we want to update
     *   }
     * })
    **/
    upsert<T extends ExtraExpenseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ExtraExpenseUpsertArgs<ExtArgs>>
    ): Prisma__ExtraExpenseClient<$Result.GetResult<Prisma.$ExtraExpensePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ExtraExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraExpenseCountArgs} args - Arguments to filter ExtraExpenses to count.
     * @example
     * // Count the number of ExtraExpenses
     * const count = await prisma.extraExpense.count({
     *   where: {
     *     // ... the filter for the ExtraExpenses we want to count
     *   }
     * })
    **/
    count<T extends ExtraExpenseCountArgs>(
      args?: Subset<T, ExtraExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExtraExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExtraExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExtraExpenseAggregateArgs>(args: Subset<T, ExtraExpenseAggregateArgs>): Prisma.PrismaPromise<GetExtraExpenseAggregateType<T>>

    /**
     * Group by ExtraExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExtraExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExtraExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExtraExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExtraExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExtraExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExtraExpense model
   */
  readonly fields: ExtraExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExtraExpense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExtraExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    financialRegistration<T extends FinancialRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FinancialRegistrationDefaultArgs<ExtArgs>>): Prisma__FinancialRegistrationClient<$Result.GetResult<Prisma.$FinancialRegistrationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ExtraExpense model
   */ 
  interface ExtraExpenseFieldRefs {
    readonly id: FieldRef<"ExtraExpense", 'String'>
    readonly expenseType: FieldRef<"ExtraExpense", 'String'>
    readonly amount: FieldRef<"ExtraExpense", 'Float'>
    readonly startDate: FieldRef<"ExtraExpense", 'DateTime'>
    readonly endDate: FieldRef<"ExtraExpense", 'DateTime'>
    readonly financialRegistrationId: FieldRef<"ExtraExpense", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ExtraExpense findUnique
   */
  export type ExtraExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraExpense
     */
    select?: ExtraExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraExpenseInclude<ExtArgs> | null
    /**
     * Filter, which ExtraExpense to fetch.
     */
    where: ExtraExpenseWhereUniqueInput
  }

  /**
   * ExtraExpense findUniqueOrThrow
   */
  export type ExtraExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraExpense
     */
    select?: ExtraExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraExpenseInclude<ExtArgs> | null
    /**
     * Filter, which ExtraExpense to fetch.
     */
    where: ExtraExpenseWhereUniqueInput
  }

  /**
   * ExtraExpense findFirst
   */
  export type ExtraExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraExpense
     */
    select?: ExtraExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraExpenseInclude<ExtArgs> | null
    /**
     * Filter, which ExtraExpense to fetch.
     */
    where?: ExtraExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtraExpenses to fetch.
     */
    orderBy?: ExtraExpenseOrderByWithRelationInput | ExtraExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExtraExpenses.
     */
    cursor?: ExtraExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtraExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtraExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExtraExpenses.
     */
    distinct?: ExtraExpenseScalarFieldEnum | ExtraExpenseScalarFieldEnum[]
  }

  /**
   * ExtraExpense findFirstOrThrow
   */
  export type ExtraExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraExpense
     */
    select?: ExtraExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraExpenseInclude<ExtArgs> | null
    /**
     * Filter, which ExtraExpense to fetch.
     */
    where?: ExtraExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtraExpenses to fetch.
     */
    orderBy?: ExtraExpenseOrderByWithRelationInput | ExtraExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExtraExpenses.
     */
    cursor?: ExtraExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtraExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtraExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExtraExpenses.
     */
    distinct?: ExtraExpenseScalarFieldEnum | ExtraExpenseScalarFieldEnum[]
  }

  /**
   * ExtraExpense findMany
   */
  export type ExtraExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraExpense
     */
    select?: ExtraExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraExpenseInclude<ExtArgs> | null
    /**
     * Filter, which ExtraExpenses to fetch.
     */
    where?: ExtraExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtraExpenses to fetch.
     */
    orderBy?: ExtraExpenseOrderByWithRelationInput | ExtraExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExtraExpenses.
     */
    cursor?: ExtraExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtraExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtraExpenses.
     */
    skip?: number
    distinct?: ExtraExpenseScalarFieldEnum | ExtraExpenseScalarFieldEnum[]
  }

  /**
   * ExtraExpense create
   */
  export type ExtraExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraExpense
     */
    select?: ExtraExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a ExtraExpense.
     */
    data: XOR<ExtraExpenseCreateInput, ExtraExpenseUncheckedCreateInput>
  }

  /**
   * ExtraExpense createMany
   */
  export type ExtraExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExtraExpenses.
     */
    data: ExtraExpenseCreateManyInput | ExtraExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExtraExpense createManyAndReturn
   */
  export type ExtraExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraExpense
     */
    select?: ExtraExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExtraExpenses.
     */
    data: ExtraExpenseCreateManyInput | ExtraExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExtraExpense update
   */
  export type ExtraExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraExpense
     */
    select?: ExtraExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a ExtraExpense.
     */
    data: XOR<ExtraExpenseUpdateInput, ExtraExpenseUncheckedUpdateInput>
    /**
     * Choose, which ExtraExpense to update.
     */
    where: ExtraExpenseWhereUniqueInput
  }

  /**
   * ExtraExpense updateMany
   */
  export type ExtraExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExtraExpenses.
     */
    data: XOR<ExtraExpenseUpdateManyMutationInput, ExtraExpenseUncheckedUpdateManyInput>
    /**
     * Filter which ExtraExpenses to update
     */
    where?: ExtraExpenseWhereInput
  }

  /**
   * ExtraExpense upsert
   */
  export type ExtraExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraExpense
     */
    select?: ExtraExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the ExtraExpense to update in case it exists.
     */
    where: ExtraExpenseWhereUniqueInput
    /**
     * In case the ExtraExpense found by the `where` argument doesn't exist, create a new ExtraExpense with this data.
     */
    create: XOR<ExtraExpenseCreateInput, ExtraExpenseUncheckedCreateInput>
    /**
     * In case the ExtraExpense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExtraExpenseUpdateInput, ExtraExpenseUncheckedUpdateInput>
  }

  /**
   * ExtraExpense delete
   */
  export type ExtraExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraExpense
     */
    select?: ExtraExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraExpenseInclude<ExtArgs> | null
    /**
     * Filter which ExtraExpense to delete.
     */
    where: ExtraExpenseWhereUniqueInput
  }

  /**
   * ExtraExpense deleteMany
   */
  export type ExtraExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExtraExpenses to delete
     */
    where?: ExtraExpenseWhereInput
  }

  /**
   * ExtraExpense without action
   */
  export type ExtraExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraExpense
     */
    select?: ExtraExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraExpenseInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    phone: 'phone',
    gender: 'gender',
    dateBirth: 'dateBirth',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AnnotationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    color: 'color',
    information: 'information'
  };

  export type AnnotationScalarFieldEnum = (typeof AnnotationScalarFieldEnum)[keyof typeof AnnotationScalarFieldEnum]


  export const ProjectsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    ownerId: 'ownerId',
    usersIds: 'usersIds',
    privacy: 'privacy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectsScalarFieldEnum = (typeof ProjectsScalarFieldEnum)[keyof typeof ProjectsScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    information: 'information',
    files: 'files',
    status: 'status',
    projectId: 'projectId',
    responsibleId: 'responsibleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ownerId: 'ownerId',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const VideoRoomScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    roomId: 'roomId',
    roomLink: 'roomLink'
  };

  export type VideoRoomScalarFieldEnum = (typeof VideoRoomScalarFieldEnum)[keyof typeof VideoRoomScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    userId: 'userId',
    chatId: 'chatId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const EmailTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    validated: 'validated',
    attempts: 'attempts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailTokenScalarFieldEnum = (typeof EmailTokenScalarFieldEnum)[keyof typeof EmailTokenScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    senderId: 'senderId',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const FinancialRegistrationScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type FinancialRegistrationScalarFieldEnum = (typeof FinancialRegistrationScalarFieldEnum)[keyof typeof FinancialRegistrationScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    address: 'address',
    phone: 'phone',
    email: 'email',
    financialRegistrationId: 'financialRegistrationId'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    type: 'type',
    amount: 'amount',
    recurringMonth: 'recurringMonth',
    contractStartDate: 'contractStartDate',
    contractEndDate: 'contractEndDate',
    financialRegistrationId: 'financialRegistrationId'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const ReceivableScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    serviceProvided: 'serviceProvided',
    amountToReceive: 'amountToReceive',
    serviceStartDate: 'serviceStartDate',
    serviceEndDate: 'serviceEndDate',
    financialRegistrationId: 'financialRegistrationId'
  };

  export type ReceivableScalarFieldEnum = (typeof ReceivableScalarFieldEnum)[keyof typeof ReceivableScalarFieldEnum]


  export const ExtraExpenseScalarFieldEnum: {
    id: 'id',
    expenseType: 'expenseType',
    amount: 'amount',
    startDate: 'startDate',
    endDate: 'endDate',
    financialRegistrationId: 'financialRegistrationId'
  };

  export type ExtraExpenseScalarFieldEnum = (typeof ExtraExpenseScalarFieldEnum)[keyof typeof ExtraExpenseScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Privacy'
   */
  export type EnumPrivacyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Privacy'>
    


  /**
   * Reference to a field of type 'Privacy[]'
   */
  export type ListEnumPrivacyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Privacy[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ClientType'
   */
  export type EnumClientTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientType'>
    


  /**
   * Reference to a field of type 'ClientType[]'
   */
  export type ListEnumClientTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientType[]'>
    


  /**
   * Reference to a field of type 'ExpenseType'
   */
  export type EnumExpenseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseType'>
    


  /**
   * Reference to a field of type 'ExpenseType[]'
   */
  export type ListEnumExpenseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    gender?: StringFilter<"User"> | string
    dateBirth?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    rooms?: RoomListRelationFilter
    ownedRooms?: RoomListRelationFilter
    projects?: ProjectsListRelationFilter
    messages?: MessageListRelationFilter
    ownedProjects?: ProjectsListRelationFilter
    tasks?: TaskListRelationFilter
    annotation?: AnnotationListRelationFilter
    emailToken?: EmailTokenListRelationFilter
    notification?: NotificationListRelationFilter
    sendNotification?: NotificationListRelationFilter
    videoRoom?: VideoRoomListRelationFilter
    financialRegistration?: FinancialRegistrationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    dateBirth?: SortOrder
    password?: SortOrder
    rooms?: RoomOrderByRelationAggregateInput
    ownedRooms?: RoomOrderByRelationAggregateInput
    projects?: ProjectsOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    ownedProjects?: ProjectsOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    annotation?: AnnotationOrderByRelationAggregateInput
    emailToken?: EmailTokenOrderByRelationAggregateInput
    notification?: NotificationOrderByRelationAggregateInput
    sendNotification?: NotificationOrderByRelationAggregateInput
    videoRoom?: VideoRoomOrderByRelationAggregateInput
    financialRegistration?: FinancialRegistrationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    gender?: StringFilter<"User"> | string
    dateBirth?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    rooms?: RoomListRelationFilter
    ownedRooms?: RoomListRelationFilter
    projects?: ProjectsListRelationFilter
    messages?: MessageListRelationFilter
    ownedProjects?: ProjectsListRelationFilter
    tasks?: TaskListRelationFilter
    annotation?: AnnotationListRelationFilter
    emailToken?: EmailTokenListRelationFilter
    notification?: NotificationListRelationFilter
    sendNotification?: NotificationListRelationFilter
    videoRoom?: VideoRoomListRelationFilter
    financialRegistration?: FinancialRegistrationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    dateBirth?: SortOrder
    password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    gender?: StringWithAggregatesFilter<"User"> | string
    dateBirth?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
  }

  export type AnnotationWhereInput = {
    AND?: AnnotationWhereInput | AnnotationWhereInput[]
    OR?: AnnotationWhereInput[]
    NOT?: AnnotationWhereInput | AnnotationWhereInput[]
    id?: StringFilter<"Annotation"> | string
    userId?: StringFilter<"Annotation"> | string
    title?: StringFilter<"Annotation"> | string
    color?: StringFilter<"Annotation"> | string
    information?: StringFilter<"Annotation"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AnnotationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    color?: SortOrder
    information?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AnnotationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnotationWhereInput | AnnotationWhereInput[]
    OR?: AnnotationWhereInput[]
    NOT?: AnnotationWhereInput | AnnotationWhereInput[]
    userId?: StringFilter<"Annotation"> | string
    title?: StringFilter<"Annotation"> | string
    color?: StringFilter<"Annotation"> | string
    information?: StringFilter<"Annotation"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AnnotationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    color?: SortOrder
    information?: SortOrder
    _count?: AnnotationCountOrderByAggregateInput
    _max?: AnnotationMaxOrderByAggregateInput
    _min?: AnnotationMinOrderByAggregateInput
  }

  export type AnnotationScalarWhereWithAggregatesInput = {
    AND?: AnnotationScalarWhereWithAggregatesInput | AnnotationScalarWhereWithAggregatesInput[]
    OR?: AnnotationScalarWhereWithAggregatesInput[]
    NOT?: AnnotationScalarWhereWithAggregatesInput | AnnotationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Annotation"> | string
    userId?: StringWithAggregatesFilter<"Annotation"> | string
    title?: StringWithAggregatesFilter<"Annotation"> | string
    color?: StringWithAggregatesFilter<"Annotation"> | string
    information?: StringWithAggregatesFilter<"Annotation"> | string
  }

  export type ProjectsWhereInput = {
    AND?: ProjectsWhereInput | ProjectsWhereInput[]
    OR?: ProjectsWhereInput[]
    NOT?: ProjectsWhereInput | ProjectsWhereInput[]
    id?: StringFilter<"Projects"> | string
    name?: StringFilter<"Projects"> | string
    color?: StringFilter<"Projects"> | string
    ownerId?: StringFilter<"Projects"> | string
    usersIds?: StringNullableListFilter<"Projects">
    privacy?: EnumPrivacyFilter<"Projects"> | $Enums.Privacy
    createdAt?: DateTimeFilter<"Projects"> | Date | string
    updatedAt?: DateTimeFilter<"Projects"> | Date | string
    users?: UserListRelationFilter
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    tasks?: TaskListRelationFilter
  }

  export type ProjectsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    ownerId?: SortOrder
    usersIds?: SortOrder
    privacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    owner?: UserOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type ProjectsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectsWhereInput | ProjectsWhereInput[]
    OR?: ProjectsWhereInput[]
    NOT?: ProjectsWhereInput | ProjectsWhereInput[]
    name?: StringFilter<"Projects"> | string
    color?: StringFilter<"Projects"> | string
    ownerId?: StringFilter<"Projects"> | string
    usersIds?: StringNullableListFilter<"Projects">
    privacy?: EnumPrivacyFilter<"Projects"> | $Enums.Privacy
    createdAt?: DateTimeFilter<"Projects"> | Date | string
    updatedAt?: DateTimeFilter<"Projects"> | Date | string
    users?: UserListRelationFilter
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    tasks?: TaskListRelationFilter
  }, "id">

  export type ProjectsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    ownerId?: SortOrder
    usersIds?: SortOrder
    privacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectsCountOrderByAggregateInput
    _max?: ProjectsMaxOrderByAggregateInput
    _min?: ProjectsMinOrderByAggregateInput
  }

  export type ProjectsScalarWhereWithAggregatesInput = {
    AND?: ProjectsScalarWhereWithAggregatesInput | ProjectsScalarWhereWithAggregatesInput[]
    OR?: ProjectsScalarWhereWithAggregatesInput[]
    NOT?: ProjectsScalarWhereWithAggregatesInput | ProjectsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Projects"> | string
    name?: StringWithAggregatesFilter<"Projects"> | string
    color?: StringWithAggregatesFilter<"Projects"> | string
    ownerId?: StringWithAggregatesFilter<"Projects"> | string
    usersIds?: StringNullableListFilter<"Projects">
    privacy?: EnumPrivacyWithAggregatesFilter<"Projects"> | $Enums.Privacy
    createdAt?: DateTimeWithAggregatesFilter<"Projects"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Projects"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    information?: StringFilter<"Task"> | string
    files?: StringFilter<"Task"> | string
    status?: EnumStatusFilter<"Task"> | $Enums.Status
    projectId?: StringFilter<"Task"> | string
    responsibleId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    responsible?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    project?: XOR<ProjectsRelationFilter, ProjectsWhereInput>
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    information?: SortOrder
    files?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    responsibleId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    responsible?: UserOrderByWithRelationInput
    project?: ProjectsOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    information?: StringFilter<"Task"> | string
    files?: StringFilter<"Task"> | string
    status?: EnumStatusFilter<"Task"> | $Enums.Status
    projectId?: StringFilter<"Task"> | string
    responsibleId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    responsible?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    project?: XOR<ProjectsRelationFilter, ProjectsWhereInput>
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    information?: SortOrder
    files?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    responsibleId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    information?: StringWithAggregatesFilter<"Task"> | string
    files?: StringWithAggregatesFilter<"Task"> | string
    status?: EnumStatusWithAggregatesFilter<"Task"> | $Enums.Status
    projectId?: StringWithAggregatesFilter<"Task"> | string
    responsibleId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    ownerId?: StringFilter<"Room"> | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    chats?: ChatListRelationFilter
    users?: UserListRelationFilter
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    VideoRoom?: VideoRoomListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    chats?: ChatOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    owner?: UserOrderByWithRelationInput
    VideoRoom?: VideoRoomOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    name?: StringFilter<"Room"> | string
    ownerId?: StringFilter<"Room"> | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    chats?: ChatListRelationFilter
    users?: UserListRelationFilter
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    VideoRoom?: VideoRoomListRelationFilter
  }, "id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Room"> | string
    name?: StringWithAggregatesFilter<"Room"> | string
    ownerId?: StringWithAggregatesFilter<"Room"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
  }

  export type VideoRoomWhereInput = {
    AND?: VideoRoomWhereInput | VideoRoomWhereInput[]
    OR?: VideoRoomWhereInput[]
    NOT?: VideoRoomWhereInput | VideoRoomWhereInput[]
    id?: StringFilter<"VideoRoom"> | string
    ownerId?: StringFilter<"VideoRoom"> | string
    roomId?: StringFilter<"VideoRoom"> | string
    roomLink?: StringFilter<"VideoRoom"> | string
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VideoRoomOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    roomId?: SortOrder
    roomLink?: SortOrder
    room?: RoomOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
  }

  export type VideoRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VideoRoomWhereInput | VideoRoomWhereInput[]
    OR?: VideoRoomWhereInput[]
    NOT?: VideoRoomWhereInput | VideoRoomWhereInput[]
    ownerId?: StringFilter<"VideoRoom"> | string
    roomId?: StringFilter<"VideoRoom"> | string
    roomLink?: StringFilter<"VideoRoom"> | string
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type VideoRoomOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    roomId?: SortOrder
    roomLink?: SortOrder
    _count?: VideoRoomCountOrderByAggregateInput
    _max?: VideoRoomMaxOrderByAggregateInput
    _min?: VideoRoomMinOrderByAggregateInput
  }

  export type VideoRoomScalarWhereWithAggregatesInput = {
    AND?: VideoRoomScalarWhereWithAggregatesInput | VideoRoomScalarWhereWithAggregatesInput[]
    OR?: VideoRoomScalarWhereWithAggregatesInput[]
    NOT?: VideoRoomScalarWhereWithAggregatesInput | VideoRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoRoom"> | string
    ownerId?: StringWithAggregatesFilter<"VideoRoom"> | string
    roomId?: StringWithAggregatesFilter<"VideoRoom"> | string
    roomLink?: StringWithAggregatesFilter<"VideoRoom"> | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: StringFilter<"Chat"> | string
    roomId?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    messages?: MessageListRelationFilter
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    messages?: MessageOrderByRelationAggregateInput
    room?: RoomOrderByWithRelationInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    roomId?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    messages?: MessageListRelationFilter
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }, "id">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chat"> | string
    roomId?: StringWithAggregatesFilter<"Chat"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    userId?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    chat?: ChatOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringFilter<"Message"> | string
    userId?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    userId?: StringWithAggregatesFilter<"Message"> | string
    chatId?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type EmailTokenWhereInput = {
    AND?: EmailTokenWhereInput | EmailTokenWhereInput[]
    OR?: EmailTokenWhereInput[]
    NOT?: EmailTokenWhereInput | EmailTokenWhereInput[]
    id?: StringFilter<"EmailToken"> | string
    email?: StringFilter<"EmailToken"> | string
    token?: StringFilter<"EmailToken"> | string
    validated?: BoolFilter<"EmailToken"> | boolean
    attempts?: IntFilter<"EmailToken"> | number
    createdAt?: DateTimeFilter<"EmailToken"> | Date | string
    updatedAt?: DateTimeFilter<"EmailToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EmailTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    validated?: SortOrder
    attempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmailTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: EmailTokenWhereInput | EmailTokenWhereInput[]
    OR?: EmailTokenWhereInput[]
    NOT?: EmailTokenWhereInput | EmailTokenWhereInput[]
    token?: StringFilter<"EmailToken"> | string
    validated?: BoolFilter<"EmailToken"> | boolean
    attempts?: IntFilter<"EmailToken"> | number
    createdAt?: DateTimeFilter<"EmailToken"> | Date | string
    updatedAt?: DateTimeFilter<"EmailToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "email">

  export type EmailTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    validated?: SortOrder
    attempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailTokenCountOrderByAggregateInput
    _avg?: EmailTokenAvgOrderByAggregateInput
    _max?: EmailTokenMaxOrderByAggregateInput
    _min?: EmailTokenMinOrderByAggregateInput
    _sum?: EmailTokenSumOrderByAggregateInput
  }

  export type EmailTokenScalarWhereWithAggregatesInput = {
    AND?: EmailTokenScalarWhereWithAggregatesInput | EmailTokenScalarWhereWithAggregatesInput[]
    OR?: EmailTokenScalarWhereWithAggregatesInput[]
    NOT?: EmailTokenScalarWhereWithAggregatesInput | EmailTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailToken"> | string
    email?: StringWithAggregatesFilter<"EmailToken"> | string
    token?: StringWithAggregatesFilter<"EmailToken"> | string
    validated?: BoolWithAggregatesFilter<"EmailToken"> | boolean
    attempts?: IntWithAggregatesFilter<"EmailToken"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EmailToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailToken"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    senderId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    senderId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    senderId?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type FinancialRegistrationWhereInput = {
    AND?: FinancialRegistrationWhereInput | FinancialRegistrationWhereInput[]
    OR?: FinancialRegistrationWhereInput[]
    NOT?: FinancialRegistrationWhereInput | FinancialRegistrationWhereInput[]
    id?: StringFilter<"FinancialRegistration"> | string
    userId?: StringFilter<"FinancialRegistration"> | string
    clients?: ClientListRelationFilter
    expenses?: ExpenseListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    Receivable?: ReceivableListRelationFilter
    ExtraExpense?: ExtraExpenseListRelationFilter
  }

  export type FinancialRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    clients?: ClientOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    Receivable?: ReceivableOrderByRelationAggregateInput
    ExtraExpense?: ExtraExpenseOrderByRelationAggregateInput
  }

  export type FinancialRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FinancialRegistrationWhereInput | FinancialRegistrationWhereInput[]
    OR?: FinancialRegistrationWhereInput[]
    NOT?: FinancialRegistrationWhereInput | FinancialRegistrationWhereInput[]
    userId?: StringFilter<"FinancialRegistration"> | string
    clients?: ClientListRelationFilter
    expenses?: ExpenseListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    Receivable?: ReceivableListRelationFilter
    ExtraExpense?: ExtraExpenseListRelationFilter
  }, "id">

  export type FinancialRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: FinancialRegistrationCountOrderByAggregateInput
    _max?: FinancialRegistrationMaxOrderByAggregateInput
    _min?: FinancialRegistrationMinOrderByAggregateInput
  }

  export type FinancialRegistrationScalarWhereWithAggregatesInput = {
    AND?: FinancialRegistrationScalarWhereWithAggregatesInput | FinancialRegistrationScalarWhereWithAggregatesInput[]
    OR?: FinancialRegistrationScalarWhereWithAggregatesInput[]
    NOT?: FinancialRegistrationScalarWhereWithAggregatesInput | FinancialRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FinancialRegistration"> | string
    userId?: StringWithAggregatesFilter<"FinancialRegistration"> | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    type?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    address?: StringFilter<"Client"> | string
    phone?: StringFilter<"Client"> | string
    email?: StringFilter<"Client"> | string
    financialRegistrationId?: StringFilter<"Client"> | string
    financialRegistration?: XOR<FinancialRegistrationRelationFilter, FinancialRegistrationWhereInput>
    Receivable?: ReceivableListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    financialRegistrationId?: SortOrder
    financialRegistration?: FinancialRegistrationOrderByWithRelationInput
    Receivable?: ReceivableOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    name?: StringFilter<"Client"> | string
    type?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    address?: StringFilter<"Client"> | string
    phone?: StringFilter<"Client"> | string
    email?: StringFilter<"Client"> | string
    financialRegistrationId?: StringFilter<"Client"> | string
    financialRegistration?: XOR<FinancialRegistrationRelationFilter, FinancialRegistrationWhereInput>
    Receivable?: ReceivableListRelationFilter
  }, "id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    financialRegistrationId?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    type?: EnumClientTypeWithAggregatesFilter<"Client"> | $Enums.ClientType
    address?: StringWithAggregatesFilter<"Client"> | string
    phone?: StringWithAggregatesFilter<"Client"> | string
    email?: StringWithAggregatesFilter<"Client"> | string
    financialRegistrationId?: StringWithAggregatesFilter<"Client"> | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    type?: EnumExpenseTypeFilter<"Expense"> | $Enums.ExpenseType
    amount?: FloatFilter<"Expense"> | number
    recurringMonth?: IntFilter<"Expense"> | number
    contractStartDate?: DateTimeFilter<"Expense"> | Date | string
    contractEndDate?: DateTimeNullableFilter<"Expense"> | Date | string | null
    financialRegistrationId?: StringFilter<"Expense"> | string
    financialRegistration?: XOR<FinancialRegistrationRelationFilter, FinancialRegistrationWhereInput>
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    recurringMonth?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrderInput | SortOrder
    financialRegistrationId?: SortOrder
    financialRegistration?: FinancialRegistrationOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    type?: EnumExpenseTypeFilter<"Expense"> | $Enums.ExpenseType
    amount?: FloatFilter<"Expense"> | number
    recurringMonth?: IntFilter<"Expense"> | number
    contractStartDate?: DateTimeFilter<"Expense"> | Date | string
    contractEndDate?: DateTimeNullableFilter<"Expense"> | Date | string | null
    financialRegistrationId?: StringFilter<"Expense"> | string
    financialRegistration?: XOR<FinancialRegistrationRelationFilter, FinancialRegistrationWhereInput>
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    recurringMonth?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrderInput | SortOrder
    financialRegistrationId?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    type?: EnumExpenseTypeWithAggregatesFilter<"Expense"> | $Enums.ExpenseType
    amount?: FloatWithAggregatesFilter<"Expense"> | number
    recurringMonth?: IntWithAggregatesFilter<"Expense"> | number
    contractStartDate?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    contractEndDate?: DateTimeNullableWithAggregatesFilter<"Expense"> | Date | string | null
    financialRegistrationId?: StringWithAggregatesFilter<"Expense"> | string
  }

  export type ReceivableWhereInput = {
    AND?: ReceivableWhereInput | ReceivableWhereInput[]
    OR?: ReceivableWhereInput[]
    NOT?: ReceivableWhereInput | ReceivableWhereInput[]
    id?: StringFilter<"Receivable"> | string
    clientId?: StringFilter<"Receivable"> | string
    serviceProvided?: StringFilter<"Receivable"> | string
    amountToReceive?: FloatFilter<"Receivable"> | number
    serviceStartDate?: DateTimeFilter<"Receivable"> | Date | string
    serviceEndDate?: DateTimeFilter<"Receivable"> | Date | string
    financialRegistrationId?: StringFilter<"Receivable"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    financialRegistration?: XOR<FinancialRegistrationRelationFilter, FinancialRegistrationWhereInput>
  }

  export type ReceivableOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    serviceProvided?: SortOrder
    amountToReceive?: SortOrder
    serviceStartDate?: SortOrder
    serviceEndDate?: SortOrder
    financialRegistrationId?: SortOrder
    client?: ClientOrderByWithRelationInput
    financialRegistration?: FinancialRegistrationOrderByWithRelationInput
  }

  export type ReceivableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReceivableWhereInput | ReceivableWhereInput[]
    OR?: ReceivableWhereInput[]
    NOT?: ReceivableWhereInput | ReceivableWhereInput[]
    clientId?: StringFilter<"Receivable"> | string
    serviceProvided?: StringFilter<"Receivable"> | string
    amountToReceive?: FloatFilter<"Receivable"> | number
    serviceStartDate?: DateTimeFilter<"Receivable"> | Date | string
    serviceEndDate?: DateTimeFilter<"Receivable"> | Date | string
    financialRegistrationId?: StringFilter<"Receivable"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    financialRegistration?: XOR<FinancialRegistrationRelationFilter, FinancialRegistrationWhereInput>
  }, "id">

  export type ReceivableOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    serviceProvided?: SortOrder
    amountToReceive?: SortOrder
    serviceStartDate?: SortOrder
    serviceEndDate?: SortOrder
    financialRegistrationId?: SortOrder
    _count?: ReceivableCountOrderByAggregateInput
    _avg?: ReceivableAvgOrderByAggregateInput
    _max?: ReceivableMaxOrderByAggregateInput
    _min?: ReceivableMinOrderByAggregateInput
    _sum?: ReceivableSumOrderByAggregateInput
  }

  export type ReceivableScalarWhereWithAggregatesInput = {
    AND?: ReceivableScalarWhereWithAggregatesInput | ReceivableScalarWhereWithAggregatesInput[]
    OR?: ReceivableScalarWhereWithAggregatesInput[]
    NOT?: ReceivableScalarWhereWithAggregatesInput | ReceivableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Receivable"> | string
    clientId?: StringWithAggregatesFilter<"Receivable"> | string
    serviceProvided?: StringWithAggregatesFilter<"Receivable"> | string
    amountToReceive?: FloatWithAggregatesFilter<"Receivable"> | number
    serviceStartDate?: DateTimeWithAggregatesFilter<"Receivable"> | Date | string
    serviceEndDate?: DateTimeWithAggregatesFilter<"Receivable"> | Date | string
    financialRegistrationId?: StringWithAggregatesFilter<"Receivable"> | string
  }

  export type ExtraExpenseWhereInput = {
    AND?: ExtraExpenseWhereInput | ExtraExpenseWhereInput[]
    OR?: ExtraExpenseWhereInput[]
    NOT?: ExtraExpenseWhereInput | ExtraExpenseWhereInput[]
    id?: StringFilter<"ExtraExpense"> | string
    expenseType?: StringFilter<"ExtraExpense"> | string
    amount?: FloatFilter<"ExtraExpense"> | number
    startDate?: DateTimeFilter<"ExtraExpense"> | Date | string
    endDate?: DateTimeFilter<"ExtraExpense"> | Date | string
    financialRegistrationId?: StringFilter<"ExtraExpense"> | string
    financialRegistration?: XOR<FinancialRegistrationRelationFilter, FinancialRegistrationWhereInput>
  }

  export type ExtraExpenseOrderByWithRelationInput = {
    id?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    financialRegistrationId?: SortOrder
    financialRegistration?: FinancialRegistrationOrderByWithRelationInput
  }

  export type ExtraExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExtraExpenseWhereInput | ExtraExpenseWhereInput[]
    OR?: ExtraExpenseWhereInput[]
    NOT?: ExtraExpenseWhereInput | ExtraExpenseWhereInput[]
    expenseType?: StringFilter<"ExtraExpense"> | string
    amount?: FloatFilter<"ExtraExpense"> | number
    startDate?: DateTimeFilter<"ExtraExpense"> | Date | string
    endDate?: DateTimeFilter<"ExtraExpense"> | Date | string
    financialRegistrationId?: StringFilter<"ExtraExpense"> | string
    financialRegistration?: XOR<FinancialRegistrationRelationFilter, FinancialRegistrationWhereInput>
  }, "id">

  export type ExtraExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    financialRegistrationId?: SortOrder
    _count?: ExtraExpenseCountOrderByAggregateInput
    _avg?: ExtraExpenseAvgOrderByAggregateInput
    _max?: ExtraExpenseMaxOrderByAggregateInput
    _min?: ExtraExpenseMinOrderByAggregateInput
    _sum?: ExtraExpenseSumOrderByAggregateInput
  }

  export type ExtraExpenseScalarWhereWithAggregatesInput = {
    AND?: ExtraExpenseScalarWhereWithAggregatesInput | ExtraExpenseScalarWhereWithAggregatesInput[]
    OR?: ExtraExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExtraExpenseScalarWhereWithAggregatesInput | ExtraExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExtraExpense"> | string
    expenseType?: StringWithAggregatesFilter<"ExtraExpense"> | string
    amount?: FloatWithAggregatesFilter<"ExtraExpense"> | number
    startDate?: DateTimeWithAggregatesFilter<"ExtraExpense"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"ExtraExpense"> | Date | string
    financialRegistrationId?: StringWithAggregatesFilter<"ExtraExpense"> | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    sendNotification?: NotificationCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomUncheckedCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sendNotification?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomUncheckedCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUncheckedUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUncheckedUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type AnnotationCreateInput = {
    id?: string
    title: string
    color: string
    information: string
    user: UserCreateNestedOneWithoutAnnotationInput
  }

  export type AnnotationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    color: string
    information: string
  }

  export type AnnotationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAnnotationNestedInput
  }

  export type AnnotationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
  }

  export type AnnotationCreateManyInput = {
    id?: string
    userId: string
    title: string
    color: string
    information: string
  }

  export type AnnotationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
  }

  export type AnnotationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectsCreateInput = {
    id?: string
    name: string
    color: string
    usersIds?: ProjectsCreateusersIdsInput | string[]
    privacy?: $Enums.Privacy
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutProjectsInput
    owner?: UserCreateNestedOneWithoutOwnedProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectsUncheckedCreateInput = {
    id?: string
    name: string
    color: string
    ownerId: string
    usersIds?: ProjectsCreateusersIdsInput | string[]
    privacy?: $Enums.Privacy
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutProjectsInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    usersIds?: ProjectsUpdateusersIdsInput | string[]
    privacy?: EnumPrivacyFieldUpdateOperationsInput | $Enums.Privacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutProjectsNestedInput
    owner?: UserUpdateOneWithoutOwnedProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    usersIds?: ProjectsUpdateusersIdsInput | string[]
    privacy?: EnumPrivacyFieldUpdateOperationsInput | $Enums.Privacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectsCreateManyInput = {
    id?: string
    name: string
    color: string
    ownerId: string
    usersIds?: ProjectsCreateusersIdsInput | string[]
    privacy?: $Enums.Privacy
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    usersIds?: ProjectsUpdateusersIdsInput | string[]
    privacy?: EnumPrivacyFieldUpdateOperationsInput | $Enums.Privacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    usersIds?: ProjectsUpdateusersIdsInput | string[]
    privacy?: EnumPrivacyFieldUpdateOperationsInput | $Enums.Privacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    information: string
    files: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    responsible?: UserCreateNestedOneWithoutTasksInput
    project: ProjectsCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    information: string
    files: string
    status?: $Enums.Status
    projectId: string
    responsibleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    files?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible?: UserUpdateOneWithoutTasksNestedInput
    project?: ProjectsUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    files?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    projectId?: StringFieldUpdateOperationsInput | string
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    information: string
    files: string
    status?: $Enums.Status
    projectId: string
    responsibleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    files?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    files?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    projectId?: StringFieldUpdateOperationsInput | string
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    id?: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    chats?: ChatCreateNestedManyWithoutRoomInput
    users?: UserCreateNestedManyWithoutRoomsInput
    owner?: UserCreateNestedOneWithoutOwnedRoomsInput
    VideoRoom?: VideoRoomCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: string
    name: string
    ownerId: string
    updatedAt?: Date | string
    createdAt?: Date | string
    chats?: ChatUncheckedCreateNestedManyWithoutRoomInput
    users?: UserUncheckedCreateNestedManyWithoutRoomsInput
    VideoRoom?: VideoRoomUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chats?: ChatUpdateManyWithoutRoomNestedInput
    users?: UserUpdateManyWithoutRoomsNestedInput
    owner?: UserUpdateOneWithoutOwnedRoomsNestedInput
    VideoRoom?: VideoRoomUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chats?: ChatUncheckedUpdateManyWithoutRoomNestedInput
    users?: UserUncheckedUpdateManyWithoutRoomsNestedInput
    VideoRoom?: VideoRoomUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: string
    name: string
    ownerId: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type RoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoRoomCreateInput = {
    id?: string
    roomLink: string
    room: RoomCreateNestedOneWithoutVideoRoomInput
    owner: UserCreateNestedOneWithoutVideoRoomInput
  }

  export type VideoRoomUncheckedCreateInput = {
    id?: string
    ownerId: string
    roomId: string
    roomLink: string
  }

  export type VideoRoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomLink?: StringFieldUpdateOperationsInput | string
    room?: RoomUpdateOneRequiredWithoutVideoRoomNestedInput
    owner?: UserUpdateOneRequiredWithoutVideoRoomNestedInput
  }

  export type VideoRoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    roomLink?: StringFieldUpdateOperationsInput | string
  }

  export type VideoRoomCreateManyInput = {
    id?: string
    ownerId: string
    roomId: string
    roomLink: string
  }

  export type VideoRoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomLink?: StringFieldUpdateOperationsInput | string
  }

  export type VideoRoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    roomLink?: StringFieldUpdateOperationsInput | string
  }

  export type ChatCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutChatInput
    room: RoomCreateNestedOneWithoutChatsInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    roomId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutChatNestedInput
    room?: RoomUpdateOneRequiredWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatCreateManyInput = {
    id?: string
    roomId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMessagesInput
    chat: ChatCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content: string
    userId: string
    chatId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    content: string
    userId: string
    chatId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTokenCreateInput = {
    id?: string
    token: string
    validated?: boolean
    attempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmailTokenInput
  }

  export type EmailTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    validated?: boolean
    attempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailTokenNestedInput
  }

  export type EmailTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    validated?: boolean
    attempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationInput
    sender: UserCreateNestedOneWithoutSendNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    senderId: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationNestedInput
    sender?: UserUpdateOneRequiredWithoutSendNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    senderId: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialRegistrationCreateInput = {
    id?: string
    clients?: ClientCreateNestedManyWithoutFinancialRegistrationInput
    expenses?: ExpenseCreateNestedManyWithoutFinancialRegistrationInput
    user: UserCreateNestedOneWithoutFinancialRegistrationInput
    Receivable?: ReceivableCreateNestedManyWithoutFinancialRegistrationInput
    ExtraExpense?: ExtraExpenseCreateNestedManyWithoutFinancialRegistrationInput
  }

  export type FinancialRegistrationUncheckedCreateInput = {
    id?: string
    userId: string
    clients?: ClientUncheckedCreateNestedManyWithoutFinancialRegistrationInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutFinancialRegistrationInput
    Receivable?: ReceivableUncheckedCreateNestedManyWithoutFinancialRegistrationInput
    ExtraExpense?: ExtraExpenseUncheckedCreateNestedManyWithoutFinancialRegistrationInput
  }

  export type FinancialRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clients?: ClientUpdateManyWithoutFinancialRegistrationNestedInput
    expenses?: ExpenseUpdateManyWithoutFinancialRegistrationNestedInput
    user?: UserUpdateOneRequiredWithoutFinancialRegistrationNestedInput
    Receivable?: ReceivableUpdateManyWithoutFinancialRegistrationNestedInput
    ExtraExpense?: ExtraExpenseUpdateManyWithoutFinancialRegistrationNestedInput
  }

  export type FinancialRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clients?: ClientUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
    Receivable?: ReceivableUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
    ExtraExpense?: ExtraExpenseUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
  }

  export type FinancialRegistrationCreateManyInput = {
    id?: string
    userId: string
  }

  export type FinancialRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientCreateInput = {
    id?: string
    name: string
    type: $Enums.ClientType
    address: string
    phone: string
    email: string
    financialRegistration: FinancialRegistrationCreateNestedOneWithoutClientsInput
    Receivable?: ReceivableCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.ClientType
    address: string
    phone: string
    email: string
    financialRegistrationId: string
    Receivable?: ReceivableUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    financialRegistration?: FinancialRegistrationUpdateOneRequiredWithoutClientsNestedInput
    Receivable?: ReceivableUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    financialRegistrationId?: StringFieldUpdateOperationsInput | string
    Receivable?: ReceivableUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    name: string
    type: $Enums.ClientType
    address: string
    phone: string
    email: string
    financialRegistrationId: string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    financialRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseCreateInput = {
    id?: string
    type: $Enums.ExpenseType
    amount: number
    recurringMonth: number
    contractStartDate: Date | string
    contractEndDate?: Date | string | null
    financialRegistration: FinancialRegistrationCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    type: $Enums.ExpenseType
    amount: number
    recurringMonth: number
    contractStartDate: Date | string
    contractEndDate?: Date | string | null
    financialRegistrationId: string
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    amount?: FloatFieldUpdateOperationsInput | number
    recurringMonth?: IntFieldUpdateOperationsInput | number
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    financialRegistration?: FinancialRegistrationUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    amount?: FloatFieldUpdateOperationsInput | number
    recurringMonth?: IntFieldUpdateOperationsInput | number
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    financialRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseCreateManyInput = {
    id?: string
    type: $Enums.ExpenseType
    amount: number
    recurringMonth: number
    contractStartDate: Date | string
    contractEndDate?: Date | string | null
    financialRegistrationId: string
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    amount?: FloatFieldUpdateOperationsInput | number
    recurringMonth?: IntFieldUpdateOperationsInput | number
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    amount?: FloatFieldUpdateOperationsInput | number
    recurringMonth?: IntFieldUpdateOperationsInput | number
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    financialRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type ReceivableCreateInput = {
    id?: string
    serviceProvided: string
    amountToReceive: number
    serviceStartDate: Date | string
    serviceEndDate: Date | string
    client: ClientCreateNestedOneWithoutReceivableInput
    financialRegistration: FinancialRegistrationCreateNestedOneWithoutReceivableInput
  }

  export type ReceivableUncheckedCreateInput = {
    id?: string
    clientId: string
    serviceProvided: string
    amountToReceive: number
    serviceStartDate: Date | string
    serviceEndDate: Date | string
    financialRegistrationId: string
  }

  export type ReceivableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceProvided?: StringFieldUpdateOperationsInput | string
    amountToReceive?: FloatFieldUpdateOperationsInput | number
    serviceStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutReceivableNestedInput
    financialRegistration?: FinancialRegistrationUpdateOneRequiredWithoutReceivableNestedInput
  }

  export type ReceivableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceProvided?: StringFieldUpdateOperationsInput | string
    amountToReceive?: FloatFieldUpdateOperationsInput | number
    serviceStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    financialRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type ReceivableCreateManyInput = {
    id?: string
    clientId: string
    serviceProvided: string
    amountToReceive: number
    serviceStartDate: Date | string
    serviceEndDate: Date | string
    financialRegistrationId: string
  }

  export type ReceivableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceProvided?: StringFieldUpdateOperationsInput | string
    amountToReceive?: FloatFieldUpdateOperationsInput | number
    serviceStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceProvided?: StringFieldUpdateOperationsInput | string
    amountToReceive?: FloatFieldUpdateOperationsInput | number
    serviceStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    financialRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type ExtraExpenseCreateInput = {
    id?: string
    expenseType: string
    amount: number
    startDate: Date | string
    endDate: Date | string
    financialRegistration: FinancialRegistrationCreateNestedOneWithoutExtraExpenseInput
  }

  export type ExtraExpenseUncheckedCreateInput = {
    id?: string
    expenseType: string
    amount: number
    startDate: Date | string
    endDate: Date | string
    financialRegistrationId: string
  }

  export type ExtraExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    financialRegistration?: FinancialRegistrationUpdateOneRequiredWithoutExtraExpenseNestedInput
  }

  export type ExtraExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    financialRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type ExtraExpenseCreateManyInput = {
    id?: string
    expenseType: string
    amount: number
    startDate: Date | string
    endDate: Date | string
    financialRegistrationId: string
  }

  export type ExtraExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtraExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    financialRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type ProjectsListRelationFilter = {
    every?: ProjectsWhereInput
    some?: ProjectsWhereInput
    none?: ProjectsWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type AnnotationListRelationFilter = {
    every?: AnnotationWhereInput
    some?: AnnotationWhereInput
    none?: AnnotationWhereInput
  }

  export type EmailTokenListRelationFilter = {
    every?: EmailTokenWhereInput
    some?: EmailTokenWhereInput
    none?: EmailTokenWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type VideoRoomListRelationFilter = {
    every?: VideoRoomWhereInput
    some?: VideoRoomWhereInput
    none?: VideoRoomWhereInput
  }

  export type FinancialRegistrationListRelationFilter = {
    every?: FinancialRegistrationWhereInput
    some?: FinancialRegistrationWhereInput
    none?: FinancialRegistrationWhereInput
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    dateBirth?: SortOrder
    password?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    dateBirth?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    dateBirth?: SortOrder
    password?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AnnotationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    color?: SortOrder
    information?: SortOrder
  }

  export type AnnotationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    color?: SortOrder
    information?: SortOrder
  }

  export type AnnotationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    color?: SortOrder
    information?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumPrivacyFilter<$PrismaModel = never> = {
    equals?: $Enums.Privacy | EnumPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.Privacy[] | ListEnumPrivacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Privacy[] | ListEnumPrivacyFieldRefInput<$PrismaModel>
    not?: NestedEnumPrivacyFilter<$PrismaModel> | $Enums.Privacy
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    ownerId?: SortOrder
    usersIds?: SortOrder
    privacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    ownerId?: SortOrder
    privacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    ownerId?: SortOrder
    privacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPrivacyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Privacy | EnumPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.Privacy[] | ListEnumPrivacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Privacy[] | ListEnumPrivacyFieldRefInput<$PrismaModel>
    not?: NestedEnumPrivacyWithAggregatesFilter<$PrismaModel> | $Enums.Privacy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrivacyFilter<$PrismaModel>
    _max?: NestedEnumPrivacyFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ProjectsRelationFilter = {
    is?: ProjectsWhereInput
    isNot?: ProjectsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    information?: SortOrder
    files?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    responsibleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    information?: SortOrder
    files?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    responsibleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    information?: SortOrder
    files?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    responsibleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RoomRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type VideoRoomCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    roomId?: SortOrder
    roomLink?: SortOrder
  }

  export type VideoRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    roomId?: SortOrder
    roomLink?: SortOrder
  }

  export type VideoRoomMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    roomId?: SortOrder
    roomLink?: SortOrder
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EmailTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    validated?: SortOrder
    attempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTokenAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type EmailTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    validated?: SortOrder
    attempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    validated?: SortOrder
    attempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTokenSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type ReceivableListRelationFilter = {
    every?: ReceivableWhereInput
    some?: ReceivableWhereInput
    none?: ReceivableWhereInput
  }

  export type ExtraExpenseListRelationFilter = {
    every?: ExtraExpenseWhereInput
    some?: ExtraExpenseWhereInput
    none?: ExtraExpenseWhereInput
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceivableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExtraExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FinancialRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FinancialRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type FinancialRegistrationRelationFilter = {
    is?: FinancialRegistrationWhereInput
    isNot?: FinancialRegistrationWhereInput
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    financialRegistrationId?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    financialRegistrationId?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    financialRegistrationId?: SortOrder
  }

  export type EnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type EnumExpenseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseTypeFilter<$PrismaModel> | $Enums.ExpenseType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    recurringMonth?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    financialRegistrationId?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
    recurringMonth?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    recurringMonth?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    financialRegistrationId?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    recurringMonth?: SortOrder
    contractStartDate?: SortOrder
    contractEndDate?: SortOrder
    financialRegistrationId?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
    recurringMonth?: SortOrder
  }

  export type EnumExpenseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseTypeFilter<$PrismaModel>
    _max?: NestedEnumExpenseTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ClientRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ReceivableCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    serviceProvided?: SortOrder
    amountToReceive?: SortOrder
    serviceStartDate?: SortOrder
    serviceEndDate?: SortOrder
    financialRegistrationId?: SortOrder
  }

  export type ReceivableAvgOrderByAggregateInput = {
    amountToReceive?: SortOrder
  }

  export type ReceivableMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    serviceProvided?: SortOrder
    amountToReceive?: SortOrder
    serviceStartDate?: SortOrder
    serviceEndDate?: SortOrder
    financialRegistrationId?: SortOrder
  }

  export type ReceivableMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    serviceProvided?: SortOrder
    amountToReceive?: SortOrder
    serviceStartDate?: SortOrder
    serviceEndDate?: SortOrder
    financialRegistrationId?: SortOrder
  }

  export type ReceivableSumOrderByAggregateInput = {
    amountToReceive?: SortOrder
  }

  export type ExtraExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    financialRegistrationId?: SortOrder
  }

  export type ExtraExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExtraExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    financialRegistrationId?: SortOrder
  }

  export type ExtraExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    expenseType?: SortOrder
    amount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    financialRegistrationId?: SortOrder
  }

  export type ExtraExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RoomCreateNestedManyWithoutUsersInput = {
    create?: XOR<RoomCreateWithoutUsersInput, RoomUncheckedCreateWithoutUsersInput> | RoomCreateWithoutUsersInput[] | RoomUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutUsersInput | RoomCreateOrConnectWithoutUsersInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutOwnerInput = {
    create?: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput> | RoomCreateWithoutOwnerInput[] | RoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutOwnerInput | RoomCreateOrConnectWithoutOwnerInput[]
    createMany?: RoomCreateManyOwnerInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type ProjectsCreateNestedManyWithoutUsersInput = {
    create?: XOR<ProjectsCreateWithoutUsersInput, ProjectsUncheckedCreateWithoutUsersInput> | ProjectsCreateWithoutUsersInput[] | ProjectsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ProjectsCreateOrConnectWithoutUsersInput | ProjectsCreateOrConnectWithoutUsersInput[]
    connect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ProjectsCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProjectsCreateWithoutOwnerInput, ProjectsUncheckedCreateWithoutOwnerInput> | ProjectsCreateWithoutOwnerInput[] | ProjectsUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectsCreateOrConnectWithoutOwnerInput | ProjectsCreateOrConnectWithoutOwnerInput[]
    createMany?: ProjectsCreateManyOwnerInputEnvelope
    connect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutResponsibleInput = {
    create?: XOR<TaskCreateWithoutResponsibleInput, TaskUncheckedCreateWithoutResponsibleInput> | TaskCreateWithoutResponsibleInput[] | TaskUncheckedCreateWithoutResponsibleInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutResponsibleInput | TaskCreateOrConnectWithoutResponsibleInput[]
    createMany?: TaskCreateManyResponsibleInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type AnnotationCreateNestedManyWithoutUserInput = {
    create?: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput> | AnnotationCreateWithoutUserInput[] | AnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutUserInput | AnnotationCreateOrConnectWithoutUserInput[]
    createMany?: AnnotationCreateManyUserInputEnvelope
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
  }

  export type EmailTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailTokenCreateWithoutUserInput, EmailTokenUncheckedCreateWithoutUserInput> | EmailTokenCreateWithoutUserInput[] | EmailTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTokenCreateOrConnectWithoutUserInput | EmailTokenCreateOrConnectWithoutUserInput[]
    createMany?: EmailTokenCreateManyUserInputEnvelope
    connect?: EmailTokenWhereUniqueInput | EmailTokenWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type VideoRoomCreateNestedManyWithoutOwnerInput = {
    create?: XOR<VideoRoomCreateWithoutOwnerInput, VideoRoomUncheckedCreateWithoutOwnerInput> | VideoRoomCreateWithoutOwnerInput[] | VideoRoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VideoRoomCreateOrConnectWithoutOwnerInput | VideoRoomCreateOrConnectWithoutOwnerInput[]
    createMany?: VideoRoomCreateManyOwnerInputEnvelope
    connect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
  }

  export type FinancialRegistrationCreateNestedManyWithoutUserInput = {
    create?: XOR<FinancialRegistrationCreateWithoutUserInput, FinancialRegistrationUncheckedCreateWithoutUserInput> | FinancialRegistrationCreateWithoutUserInput[] | FinancialRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialRegistrationCreateOrConnectWithoutUserInput | FinancialRegistrationCreateOrConnectWithoutUserInput[]
    createMany?: FinancialRegistrationCreateManyUserInputEnvelope
    connect?: FinancialRegistrationWhereUniqueInput | FinancialRegistrationWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<RoomCreateWithoutUsersInput, RoomUncheckedCreateWithoutUsersInput> | RoomCreateWithoutUsersInput[] | RoomUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutUsersInput | RoomCreateOrConnectWithoutUsersInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput> | RoomCreateWithoutOwnerInput[] | RoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutOwnerInput | RoomCreateOrConnectWithoutOwnerInput[]
    createMany?: RoomCreateManyOwnerInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type ProjectsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ProjectsCreateWithoutUsersInput, ProjectsUncheckedCreateWithoutUsersInput> | ProjectsCreateWithoutUsersInput[] | ProjectsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ProjectsCreateOrConnectWithoutUsersInput | ProjectsCreateOrConnectWithoutUsersInput[]
    connect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ProjectsUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProjectsCreateWithoutOwnerInput, ProjectsUncheckedCreateWithoutOwnerInput> | ProjectsCreateWithoutOwnerInput[] | ProjectsUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectsCreateOrConnectWithoutOwnerInput | ProjectsCreateOrConnectWithoutOwnerInput[]
    createMany?: ProjectsCreateManyOwnerInputEnvelope
    connect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutResponsibleInput = {
    create?: XOR<TaskCreateWithoutResponsibleInput, TaskUncheckedCreateWithoutResponsibleInput> | TaskCreateWithoutResponsibleInput[] | TaskUncheckedCreateWithoutResponsibleInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutResponsibleInput | TaskCreateOrConnectWithoutResponsibleInput[]
    createMany?: TaskCreateManyResponsibleInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type AnnotationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput> | AnnotationCreateWithoutUserInput[] | AnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutUserInput | AnnotationCreateOrConnectWithoutUserInput[]
    createMany?: AnnotationCreateManyUserInputEnvelope
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
  }

  export type EmailTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailTokenCreateWithoutUserInput, EmailTokenUncheckedCreateWithoutUserInput> | EmailTokenCreateWithoutUserInput[] | EmailTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTokenCreateOrConnectWithoutUserInput | EmailTokenCreateOrConnectWithoutUserInput[]
    createMany?: EmailTokenCreateManyUserInputEnvelope
    connect?: EmailTokenWhereUniqueInput | EmailTokenWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type VideoRoomUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<VideoRoomCreateWithoutOwnerInput, VideoRoomUncheckedCreateWithoutOwnerInput> | VideoRoomCreateWithoutOwnerInput[] | VideoRoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VideoRoomCreateOrConnectWithoutOwnerInput | VideoRoomCreateOrConnectWithoutOwnerInput[]
    createMany?: VideoRoomCreateManyOwnerInputEnvelope
    connect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
  }

  export type FinancialRegistrationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FinancialRegistrationCreateWithoutUserInput, FinancialRegistrationUncheckedCreateWithoutUserInput> | FinancialRegistrationCreateWithoutUserInput[] | FinancialRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialRegistrationCreateOrConnectWithoutUserInput | FinancialRegistrationCreateOrConnectWithoutUserInput[]
    createMany?: FinancialRegistrationCreateManyUserInputEnvelope
    connect?: FinancialRegistrationWhereUniqueInput | FinancialRegistrationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type RoomUpdateManyWithoutUsersNestedInput = {
    create?: XOR<RoomCreateWithoutUsersInput, RoomUncheckedCreateWithoutUsersInput> | RoomCreateWithoutUsersInput[] | RoomUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutUsersInput | RoomCreateOrConnectWithoutUsersInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutUsersInput | RoomUpsertWithWhereUniqueWithoutUsersInput[]
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutUsersInput | RoomUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutUsersInput | RoomUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput> | RoomCreateWithoutOwnerInput[] | RoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutOwnerInput | RoomCreateOrConnectWithoutOwnerInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutOwnerInput | RoomUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: RoomCreateManyOwnerInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutOwnerInput | RoomUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutOwnerInput | RoomUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type ProjectsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ProjectsCreateWithoutUsersInput, ProjectsUncheckedCreateWithoutUsersInput> | ProjectsCreateWithoutUsersInput[] | ProjectsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ProjectsCreateOrConnectWithoutUsersInput | ProjectsCreateOrConnectWithoutUsersInput[]
    upsert?: ProjectsUpsertWithWhereUniqueWithoutUsersInput | ProjectsUpsertWithWhereUniqueWithoutUsersInput[]
    set?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    disconnect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    delete?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    connect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    update?: ProjectsUpdateWithWhereUniqueWithoutUsersInput | ProjectsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ProjectsUpdateManyWithWhereWithoutUsersInput | ProjectsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ProjectsScalarWhereInput | ProjectsScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ProjectsUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProjectsCreateWithoutOwnerInput, ProjectsUncheckedCreateWithoutOwnerInput> | ProjectsCreateWithoutOwnerInput[] | ProjectsUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectsCreateOrConnectWithoutOwnerInput | ProjectsCreateOrConnectWithoutOwnerInput[]
    upsert?: ProjectsUpsertWithWhereUniqueWithoutOwnerInput | ProjectsUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProjectsCreateManyOwnerInputEnvelope
    set?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    disconnect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    delete?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    connect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    update?: ProjectsUpdateWithWhereUniqueWithoutOwnerInput | ProjectsUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProjectsUpdateManyWithWhereWithoutOwnerInput | ProjectsUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProjectsScalarWhereInput | ProjectsScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutResponsibleNestedInput = {
    create?: XOR<TaskCreateWithoutResponsibleInput, TaskUncheckedCreateWithoutResponsibleInput> | TaskCreateWithoutResponsibleInput[] | TaskUncheckedCreateWithoutResponsibleInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutResponsibleInput | TaskCreateOrConnectWithoutResponsibleInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutResponsibleInput | TaskUpsertWithWhereUniqueWithoutResponsibleInput[]
    createMany?: TaskCreateManyResponsibleInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutResponsibleInput | TaskUpdateWithWhereUniqueWithoutResponsibleInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutResponsibleInput | TaskUpdateManyWithWhereWithoutResponsibleInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AnnotationUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput> | AnnotationCreateWithoutUserInput[] | AnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutUserInput | AnnotationCreateOrConnectWithoutUserInput[]
    upsert?: AnnotationUpsertWithWhereUniqueWithoutUserInput | AnnotationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnnotationCreateManyUserInputEnvelope
    set?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    disconnect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    delete?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    update?: AnnotationUpdateWithWhereUniqueWithoutUserInput | AnnotationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnnotationUpdateManyWithWhereWithoutUserInput | AnnotationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
  }

  export type EmailTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailTokenCreateWithoutUserInput, EmailTokenUncheckedCreateWithoutUserInput> | EmailTokenCreateWithoutUserInput[] | EmailTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTokenCreateOrConnectWithoutUserInput | EmailTokenCreateOrConnectWithoutUserInput[]
    upsert?: EmailTokenUpsertWithWhereUniqueWithoutUserInput | EmailTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailTokenCreateManyUserInputEnvelope
    set?: EmailTokenWhereUniqueInput | EmailTokenWhereUniqueInput[]
    disconnect?: EmailTokenWhereUniqueInput | EmailTokenWhereUniqueInput[]
    delete?: EmailTokenWhereUniqueInput | EmailTokenWhereUniqueInput[]
    connect?: EmailTokenWhereUniqueInput | EmailTokenWhereUniqueInput[]
    update?: EmailTokenUpdateWithWhereUniqueWithoutUserInput | EmailTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailTokenUpdateManyWithWhereWithoutUserInput | EmailTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailTokenScalarWhereInput | EmailTokenScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type VideoRoomUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<VideoRoomCreateWithoutOwnerInput, VideoRoomUncheckedCreateWithoutOwnerInput> | VideoRoomCreateWithoutOwnerInput[] | VideoRoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VideoRoomCreateOrConnectWithoutOwnerInput | VideoRoomCreateOrConnectWithoutOwnerInput[]
    upsert?: VideoRoomUpsertWithWhereUniqueWithoutOwnerInput | VideoRoomUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: VideoRoomCreateManyOwnerInputEnvelope
    set?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    disconnect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    delete?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    connect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    update?: VideoRoomUpdateWithWhereUniqueWithoutOwnerInput | VideoRoomUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: VideoRoomUpdateManyWithWhereWithoutOwnerInput | VideoRoomUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: VideoRoomScalarWhereInput | VideoRoomScalarWhereInput[]
  }

  export type FinancialRegistrationUpdateManyWithoutUserNestedInput = {
    create?: XOR<FinancialRegistrationCreateWithoutUserInput, FinancialRegistrationUncheckedCreateWithoutUserInput> | FinancialRegistrationCreateWithoutUserInput[] | FinancialRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialRegistrationCreateOrConnectWithoutUserInput | FinancialRegistrationCreateOrConnectWithoutUserInput[]
    upsert?: FinancialRegistrationUpsertWithWhereUniqueWithoutUserInput | FinancialRegistrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FinancialRegistrationCreateManyUserInputEnvelope
    set?: FinancialRegistrationWhereUniqueInput | FinancialRegistrationWhereUniqueInput[]
    disconnect?: FinancialRegistrationWhereUniqueInput | FinancialRegistrationWhereUniqueInput[]
    delete?: FinancialRegistrationWhereUniqueInput | FinancialRegistrationWhereUniqueInput[]
    connect?: FinancialRegistrationWhereUniqueInput | FinancialRegistrationWhereUniqueInput[]
    update?: FinancialRegistrationUpdateWithWhereUniqueWithoutUserInput | FinancialRegistrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FinancialRegistrationUpdateManyWithWhereWithoutUserInput | FinancialRegistrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FinancialRegistrationScalarWhereInput | FinancialRegistrationScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<RoomCreateWithoutUsersInput, RoomUncheckedCreateWithoutUsersInput> | RoomCreateWithoutUsersInput[] | RoomUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutUsersInput | RoomCreateOrConnectWithoutUsersInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutUsersInput | RoomUpsertWithWhereUniqueWithoutUsersInput[]
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutUsersInput | RoomUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutUsersInput | RoomUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput> | RoomCreateWithoutOwnerInput[] | RoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutOwnerInput | RoomCreateOrConnectWithoutOwnerInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutOwnerInput | RoomUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: RoomCreateManyOwnerInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutOwnerInput | RoomUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutOwnerInput | RoomUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type ProjectsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ProjectsCreateWithoutUsersInput, ProjectsUncheckedCreateWithoutUsersInput> | ProjectsCreateWithoutUsersInput[] | ProjectsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ProjectsCreateOrConnectWithoutUsersInput | ProjectsCreateOrConnectWithoutUsersInput[]
    upsert?: ProjectsUpsertWithWhereUniqueWithoutUsersInput | ProjectsUpsertWithWhereUniqueWithoutUsersInput[]
    set?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    disconnect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    delete?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    connect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    update?: ProjectsUpdateWithWhereUniqueWithoutUsersInput | ProjectsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ProjectsUpdateManyWithWhereWithoutUsersInput | ProjectsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ProjectsScalarWhereInput | ProjectsScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ProjectsUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProjectsCreateWithoutOwnerInput, ProjectsUncheckedCreateWithoutOwnerInput> | ProjectsCreateWithoutOwnerInput[] | ProjectsUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectsCreateOrConnectWithoutOwnerInput | ProjectsCreateOrConnectWithoutOwnerInput[]
    upsert?: ProjectsUpsertWithWhereUniqueWithoutOwnerInput | ProjectsUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProjectsCreateManyOwnerInputEnvelope
    set?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    disconnect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    delete?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    connect?: ProjectsWhereUniqueInput | ProjectsWhereUniqueInput[]
    update?: ProjectsUpdateWithWhereUniqueWithoutOwnerInput | ProjectsUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProjectsUpdateManyWithWhereWithoutOwnerInput | ProjectsUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProjectsScalarWhereInput | ProjectsScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutResponsibleNestedInput = {
    create?: XOR<TaskCreateWithoutResponsibleInput, TaskUncheckedCreateWithoutResponsibleInput> | TaskCreateWithoutResponsibleInput[] | TaskUncheckedCreateWithoutResponsibleInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutResponsibleInput | TaskCreateOrConnectWithoutResponsibleInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutResponsibleInput | TaskUpsertWithWhereUniqueWithoutResponsibleInput[]
    createMany?: TaskCreateManyResponsibleInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutResponsibleInput | TaskUpdateWithWhereUniqueWithoutResponsibleInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutResponsibleInput | TaskUpdateManyWithWhereWithoutResponsibleInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AnnotationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput> | AnnotationCreateWithoutUserInput[] | AnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutUserInput | AnnotationCreateOrConnectWithoutUserInput[]
    upsert?: AnnotationUpsertWithWhereUniqueWithoutUserInput | AnnotationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnnotationCreateManyUserInputEnvelope
    set?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    disconnect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    delete?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    update?: AnnotationUpdateWithWhereUniqueWithoutUserInput | AnnotationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnnotationUpdateManyWithWhereWithoutUserInput | AnnotationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
  }

  export type EmailTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailTokenCreateWithoutUserInput, EmailTokenUncheckedCreateWithoutUserInput> | EmailTokenCreateWithoutUserInput[] | EmailTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailTokenCreateOrConnectWithoutUserInput | EmailTokenCreateOrConnectWithoutUserInput[]
    upsert?: EmailTokenUpsertWithWhereUniqueWithoutUserInput | EmailTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailTokenCreateManyUserInputEnvelope
    set?: EmailTokenWhereUniqueInput | EmailTokenWhereUniqueInput[]
    disconnect?: EmailTokenWhereUniqueInput | EmailTokenWhereUniqueInput[]
    delete?: EmailTokenWhereUniqueInput | EmailTokenWhereUniqueInput[]
    connect?: EmailTokenWhereUniqueInput | EmailTokenWhereUniqueInput[]
    update?: EmailTokenUpdateWithWhereUniqueWithoutUserInput | EmailTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailTokenUpdateManyWithWhereWithoutUserInput | EmailTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailTokenScalarWhereInput | EmailTokenScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type VideoRoomUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<VideoRoomCreateWithoutOwnerInput, VideoRoomUncheckedCreateWithoutOwnerInput> | VideoRoomCreateWithoutOwnerInput[] | VideoRoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VideoRoomCreateOrConnectWithoutOwnerInput | VideoRoomCreateOrConnectWithoutOwnerInput[]
    upsert?: VideoRoomUpsertWithWhereUniqueWithoutOwnerInput | VideoRoomUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: VideoRoomCreateManyOwnerInputEnvelope
    set?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    disconnect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    delete?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    connect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    update?: VideoRoomUpdateWithWhereUniqueWithoutOwnerInput | VideoRoomUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: VideoRoomUpdateManyWithWhereWithoutOwnerInput | VideoRoomUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: VideoRoomScalarWhereInput | VideoRoomScalarWhereInput[]
  }

  export type FinancialRegistrationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FinancialRegistrationCreateWithoutUserInput, FinancialRegistrationUncheckedCreateWithoutUserInput> | FinancialRegistrationCreateWithoutUserInput[] | FinancialRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialRegistrationCreateOrConnectWithoutUserInput | FinancialRegistrationCreateOrConnectWithoutUserInput[]
    upsert?: FinancialRegistrationUpsertWithWhereUniqueWithoutUserInput | FinancialRegistrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FinancialRegistrationCreateManyUserInputEnvelope
    set?: FinancialRegistrationWhereUniqueInput | FinancialRegistrationWhereUniqueInput[]
    disconnect?: FinancialRegistrationWhereUniqueInput | FinancialRegistrationWhereUniqueInput[]
    delete?: FinancialRegistrationWhereUniqueInput | FinancialRegistrationWhereUniqueInput[]
    connect?: FinancialRegistrationWhereUniqueInput | FinancialRegistrationWhereUniqueInput[]
    update?: FinancialRegistrationUpdateWithWhereUniqueWithoutUserInput | FinancialRegistrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FinancialRegistrationUpdateManyWithWhereWithoutUserInput | FinancialRegistrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FinancialRegistrationScalarWhereInput | FinancialRegistrationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAnnotationInput = {
    create?: XOR<UserCreateWithoutAnnotationInput, UserUncheckedCreateWithoutAnnotationInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnotationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAnnotationNestedInput = {
    create?: XOR<UserCreateWithoutAnnotationInput, UserUncheckedCreateWithoutAnnotationInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnotationInput
    upsert?: UserUpsertWithoutAnnotationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnotationInput, UserUpdateWithoutAnnotationInput>, UserUncheckedUpdateWithoutAnnotationInput>
  }

  export type ProjectsCreateusersIdsInput = {
    set: string[]
  }

  export type UserCreateNestedManyWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput> | UserCreateWithoutProjectsInput[] | UserUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput | UserCreateOrConnectWithoutProjectsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOwnedProjectsInput = {
    create?: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput> | UserCreateWithoutProjectsInput[] | UserUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput | UserCreateOrConnectWithoutProjectsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectsUpdateusersIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumPrivacyFieldUpdateOperationsInput = {
    set?: $Enums.Privacy
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput> | UserCreateWithoutProjectsInput[] | UserUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput | UserCreateOrConnectWithoutProjectsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProjectsInput | UserUpsertWithWhereUniqueWithoutProjectsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProjectsInput | UserUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProjectsInput | UserUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUpdateOneWithoutOwnedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedProjectsInput
    upsert?: UserUpsertWithoutOwnedProjectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedProjectsInput, UserUpdateWithoutOwnedProjectsInput>, UserUncheckedUpdateWithoutOwnedProjectsInput>
  }

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput> | UserCreateWithoutProjectsInput[] | UserUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput | UserCreateOrConnectWithoutProjectsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProjectsInput | UserUpsertWithWhereUniqueWithoutProjectsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProjectsInput | UserUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProjectsInput | UserUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTasksInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectsCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectsCreateWithoutTasksInput, ProjectsUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutTasksInput
    connect?: ProjectsWhereUniqueInput
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type UserUpdateOneWithoutTasksNestedInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    upsert?: UserUpsertWithoutTasksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksInput, UserUpdateWithoutTasksInput>, UserUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectsUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ProjectsCreateWithoutTasksInput, ProjectsUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutTasksInput
    upsert?: ProjectsUpsertWithoutTasksInput
    connect?: ProjectsWhereUniqueInput
    update?: XOR<XOR<ProjectsUpdateToOneWithWhereWithoutTasksInput, ProjectsUpdateWithoutTasksInput>, ProjectsUncheckedUpdateWithoutTasksInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ChatCreateNestedManyWithoutRoomInput = {
    create?: XOR<ChatCreateWithoutRoomInput, ChatUncheckedCreateWithoutRoomInput> | ChatCreateWithoutRoomInput[] | ChatUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutRoomInput | ChatCreateOrConnectWithoutRoomInput[]
    createMany?: ChatCreateManyRoomInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutRoomsInput = {
    create?: XOR<UserCreateWithoutRoomsInput, UserUncheckedCreateWithoutRoomsInput> | UserCreateWithoutRoomsInput[] | UserUncheckedCreateWithoutRoomsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoomsInput | UserCreateOrConnectWithoutRoomsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOwnedRoomsInput = {
    create?: XOR<UserCreateWithoutOwnedRoomsInput, UserUncheckedCreateWithoutOwnedRoomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedRoomsInput
    connect?: UserWhereUniqueInput
  }

  export type VideoRoomCreateNestedManyWithoutRoomInput = {
    create?: XOR<VideoRoomCreateWithoutRoomInput, VideoRoomUncheckedCreateWithoutRoomInput> | VideoRoomCreateWithoutRoomInput[] | VideoRoomUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: VideoRoomCreateOrConnectWithoutRoomInput | VideoRoomCreateOrConnectWithoutRoomInput[]
    createMany?: VideoRoomCreateManyRoomInputEnvelope
    connect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<ChatCreateWithoutRoomInput, ChatUncheckedCreateWithoutRoomInput> | ChatCreateWithoutRoomInput[] | ChatUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutRoomInput | ChatCreateOrConnectWithoutRoomInput[]
    createMany?: ChatCreateManyRoomInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoomsInput = {
    create?: XOR<UserCreateWithoutRoomsInput, UserUncheckedCreateWithoutRoomsInput> | UserCreateWithoutRoomsInput[] | UserUncheckedCreateWithoutRoomsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoomsInput | UserCreateOrConnectWithoutRoomsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VideoRoomUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<VideoRoomCreateWithoutRoomInput, VideoRoomUncheckedCreateWithoutRoomInput> | VideoRoomCreateWithoutRoomInput[] | VideoRoomUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: VideoRoomCreateOrConnectWithoutRoomInput | VideoRoomCreateOrConnectWithoutRoomInput[]
    createMany?: VideoRoomCreateManyRoomInputEnvelope
    connect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
  }

  export type ChatUpdateManyWithoutRoomNestedInput = {
    create?: XOR<ChatCreateWithoutRoomInput, ChatUncheckedCreateWithoutRoomInput> | ChatCreateWithoutRoomInput[] | ChatUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutRoomInput | ChatCreateOrConnectWithoutRoomInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutRoomInput | ChatUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: ChatCreateManyRoomInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutRoomInput | ChatUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutRoomInput | ChatUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type UserUpdateManyWithoutRoomsNestedInput = {
    create?: XOR<UserCreateWithoutRoomsInput, UserUncheckedCreateWithoutRoomsInput> | UserCreateWithoutRoomsInput[] | UserUncheckedCreateWithoutRoomsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoomsInput | UserCreateOrConnectWithoutRoomsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoomsInput | UserUpsertWithWhereUniqueWithoutRoomsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoomsInput | UserUpdateWithWhereUniqueWithoutRoomsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoomsInput | UserUpdateManyWithWhereWithoutRoomsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUpdateOneWithoutOwnedRoomsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedRoomsInput, UserUncheckedCreateWithoutOwnedRoomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedRoomsInput
    upsert?: UserUpsertWithoutOwnedRoomsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedRoomsInput, UserUpdateWithoutOwnedRoomsInput>, UserUncheckedUpdateWithoutOwnedRoomsInput>
  }

  export type VideoRoomUpdateManyWithoutRoomNestedInput = {
    create?: XOR<VideoRoomCreateWithoutRoomInput, VideoRoomUncheckedCreateWithoutRoomInput> | VideoRoomCreateWithoutRoomInput[] | VideoRoomUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: VideoRoomCreateOrConnectWithoutRoomInput | VideoRoomCreateOrConnectWithoutRoomInput[]
    upsert?: VideoRoomUpsertWithWhereUniqueWithoutRoomInput | VideoRoomUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: VideoRoomCreateManyRoomInputEnvelope
    set?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    disconnect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    delete?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    connect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    update?: VideoRoomUpdateWithWhereUniqueWithoutRoomInput | VideoRoomUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: VideoRoomUpdateManyWithWhereWithoutRoomInput | VideoRoomUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: VideoRoomScalarWhereInput | VideoRoomScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<ChatCreateWithoutRoomInput, ChatUncheckedCreateWithoutRoomInput> | ChatCreateWithoutRoomInput[] | ChatUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutRoomInput | ChatCreateOrConnectWithoutRoomInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutRoomInput | ChatUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: ChatCreateManyRoomInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutRoomInput | ChatUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutRoomInput | ChatUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoomsNestedInput = {
    create?: XOR<UserCreateWithoutRoomsInput, UserUncheckedCreateWithoutRoomsInput> | UserCreateWithoutRoomsInput[] | UserUncheckedCreateWithoutRoomsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoomsInput | UserCreateOrConnectWithoutRoomsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoomsInput | UserUpsertWithWhereUniqueWithoutRoomsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoomsInput | UserUpdateWithWhereUniqueWithoutRoomsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoomsInput | UserUpdateManyWithWhereWithoutRoomsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VideoRoomUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<VideoRoomCreateWithoutRoomInput, VideoRoomUncheckedCreateWithoutRoomInput> | VideoRoomCreateWithoutRoomInput[] | VideoRoomUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: VideoRoomCreateOrConnectWithoutRoomInput | VideoRoomCreateOrConnectWithoutRoomInput[]
    upsert?: VideoRoomUpsertWithWhereUniqueWithoutRoomInput | VideoRoomUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: VideoRoomCreateManyRoomInputEnvelope
    set?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    disconnect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    delete?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    connect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    update?: VideoRoomUpdateWithWhereUniqueWithoutRoomInput | VideoRoomUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: VideoRoomUpdateManyWithWhereWithoutRoomInput | VideoRoomUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: VideoRoomScalarWhereInput | VideoRoomScalarWhereInput[]
  }

  export type RoomCreateNestedOneWithoutVideoRoomInput = {
    create?: XOR<RoomCreateWithoutVideoRoomInput, RoomUncheckedCreateWithoutVideoRoomInput>
    connectOrCreate?: RoomCreateOrConnectWithoutVideoRoomInput
    connect?: RoomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVideoRoomInput = {
    create?: XOR<UserCreateWithoutVideoRoomInput, UserUncheckedCreateWithoutVideoRoomInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideoRoomInput
    connect?: UserWhereUniqueInput
  }

  export type RoomUpdateOneRequiredWithoutVideoRoomNestedInput = {
    create?: XOR<RoomCreateWithoutVideoRoomInput, RoomUncheckedCreateWithoutVideoRoomInput>
    connectOrCreate?: RoomCreateOrConnectWithoutVideoRoomInput
    upsert?: RoomUpsertWithoutVideoRoomInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutVideoRoomInput, RoomUpdateWithoutVideoRoomInput>, RoomUncheckedUpdateWithoutVideoRoomInput>
  }

  export type UserUpdateOneRequiredWithoutVideoRoomNestedInput = {
    create?: XOR<UserCreateWithoutVideoRoomInput, UserUncheckedCreateWithoutVideoRoomInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideoRoomInput
    upsert?: UserUpsertWithoutVideoRoomInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVideoRoomInput, UserUpdateWithoutVideoRoomInput>, UserUncheckedUpdateWithoutVideoRoomInput>
  }

  export type MessageCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type RoomCreateNestedOneWithoutChatsInput = {
    create?: XOR<RoomCreateWithoutChatsInput, RoomUncheckedCreateWithoutChatsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutChatsInput
    connect?: RoomWhereUniqueInput
  }

  export type MessageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type RoomUpdateOneRequiredWithoutChatsNestedInput = {
    create?: XOR<RoomCreateWithoutChatsInput, RoomUncheckedCreateWithoutChatsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutChatsInput
    upsert?: RoomUpsertWithoutChatsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutChatsInput, RoomUpdateWithoutChatsInput>, RoomUncheckedUpdateWithoutChatsInput>
  }

  export type MessageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    upsert?: ChatUpsertWithoutMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessagesInput, ChatUpdateWithoutMessagesInput>, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutEmailTokenInput = {
    create?: XOR<UserCreateWithoutEmailTokenInput, UserUncheckedCreateWithoutEmailTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailTokenInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutEmailTokenNestedInput = {
    create?: XOR<UserCreateWithoutEmailTokenInput, UserUncheckedCreateWithoutEmailTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailTokenInput
    upsert?: UserUpsertWithoutEmailTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailTokenInput, UserUpdateWithoutEmailTokenInput>, UserUncheckedUpdateWithoutEmailTokenInput>
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSendNotificationInput = {
    create?: XOR<UserCreateWithoutSendNotificationInput, UserUncheckedCreateWithoutSendNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutSendNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateOneRequiredWithoutSendNotificationNestedInput = {
    create?: XOR<UserCreateWithoutSendNotificationInput, UserUncheckedCreateWithoutSendNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutSendNotificationInput
    upsert?: UserUpsertWithoutSendNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSendNotificationInput, UserUpdateWithoutSendNotificationInput>, UserUncheckedUpdateWithoutSendNotificationInput>
  }

  export type ClientCreateNestedManyWithoutFinancialRegistrationInput = {
    create?: XOR<ClientCreateWithoutFinancialRegistrationInput, ClientUncheckedCreateWithoutFinancialRegistrationInput> | ClientCreateWithoutFinancialRegistrationInput[] | ClientUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutFinancialRegistrationInput | ClientCreateOrConnectWithoutFinancialRegistrationInput[]
    createMany?: ClientCreateManyFinancialRegistrationInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutFinancialRegistrationInput = {
    create?: XOR<ExpenseCreateWithoutFinancialRegistrationInput, ExpenseUncheckedCreateWithoutFinancialRegistrationInput> | ExpenseCreateWithoutFinancialRegistrationInput[] | ExpenseUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutFinancialRegistrationInput | ExpenseCreateOrConnectWithoutFinancialRegistrationInput[]
    createMany?: ExpenseCreateManyFinancialRegistrationInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutFinancialRegistrationInput = {
    create?: XOR<UserCreateWithoutFinancialRegistrationInput, UserUncheckedCreateWithoutFinancialRegistrationInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialRegistrationInput
    connect?: UserWhereUniqueInput
  }

  export type ReceivableCreateNestedManyWithoutFinancialRegistrationInput = {
    create?: XOR<ReceivableCreateWithoutFinancialRegistrationInput, ReceivableUncheckedCreateWithoutFinancialRegistrationInput> | ReceivableCreateWithoutFinancialRegistrationInput[] | ReceivableUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutFinancialRegistrationInput | ReceivableCreateOrConnectWithoutFinancialRegistrationInput[]
    createMany?: ReceivableCreateManyFinancialRegistrationInputEnvelope
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
  }

  export type ExtraExpenseCreateNestedManyWithoutFinancialRegistrationInput = {
    create?: XOR<ExtraExpenseCreateWithoutFinancialRegistrationInput, ExtraExpenseUncheckedCreateWithoutFinancialRegistrationInput> | ExtraExpenseCreateWithoutFinancialRegistrationInput[] | ExtraExpenseUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ExtraExpenseCreateOrConnectWithoutFinancialRegistrationInput | ExtraExpenseCreateOrConnectWithoutFinancialRegistrationInput[]
    createMany?: ExtraExpenseCreateManyFinancialRegistrationInputEnvelope
    connect?: ExtraExpenseWhereUniqueInput | ExtraExpenseWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutFinancialRegistrationInput = {
    create?: XOR<ClientCreateWithoutFinancialRegistrationInput, ClientUncheckedCreateWithoutFinancialRegistrationInput> | ClientCreateWithoutFinancialRegistrationInput[] | ClientUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutFinancialRegistrationInput | ClientCreateOrConnectWithoutFinancialRegistrationInput[]
    createMany?: ClientCreateManyFinancialRegistrationInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutFinancialRegistrationInput = {
    create?: XOR<ExpenseCreateWithoutFinancialRegistrationInput, ExpenseUncheckedCreateWithoutFinancialRegistrationInput> | ExpenseCreateWithoutFinancialRegistrationInput[] | ExpenseUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutFinancialRegistrationInput | ExpenseCreateOrConnectWithoutFinancialRegistrationInput[]
    createMany?: ExpenseCreateManyFinancialRegistrationInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ReceivableUncheckedCreateNestedManyWithoutFinancialRegistrationInput = {
    create?: XOR<ReceivableCreateWithoutFinancialRegistrationInput, ReceivableUncheckedCreateWithoutFinancialRegistrationInput> | ReceivableCreateWithoutFinancialRegistrationInput[] | ReceivableUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutFinancialRegistrationInput | ReceivableCreateOrConnectWithoutFinancialRegistrationInput[]
    createMany?: ReceivableCreateManyFinancialRegistrationInputEnvelope
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
  }

  export type ExtraExpenseUncheckedCreateNestedManyWithoutFinancialRegistrationInput = {
    create?: XOR<ExtraExpenseCreateWithoutFinancialRegistrationInput, ExtraExpenseUncheckedCreateWithoutFinancialRegistrationInput> | ExtraExpenseCreateWithoutFinancialRegistrationInput[] | ExtraExpenseUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ExtraExpenseCreateOrConnectWithoutFinancialRegistrationInput | ExtraExpenseCreateOrConnectWithoutFinancialRegistrationInput[]
    createMany?: ExtraExpenseCreateManyFinancialRegistrationInputEnvelope
    connect?: ExtraExpenseWhereUniqueInput | ExtraExpenseWhereUniqueInput[]
  }

  export type ClientUpdateManyWithoutFinancialRegistrationNestedInput = {
    create?: XOR<ClientCreateWithoutFinancialRegistrationInput, ClientUncheckedCreateWithoutFinancialRegistrationInput> | ClientCreateWithoutFinancialRegistrationInput[] | ClientUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutFinancialRegistrationInput | ClientCreateOrConnectWithoutFinancialRegistrationInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutFinancialRegistrationInput | ClientUpsertWithWhereUniqueWithoutFinancialRegistrationInput[]
    createMany?: ClientCreateManyFinancialRegistrationInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutFinancialRegistrationInput | ClientUpdateWithWhereUniqueWithoutFinancialRegistrationInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutFinancialRegistrationInput | ClientUpdateManyWithWhereWithoutFinancialRegistrationInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutFinancialRegistrationNestedInput = {
    create?: XOR<ExpenseCreateWithoutFinancialRegistrationInput, ExpenseUncheckedCreateWithoutFinancialRegistrationInput> | ExpenseCreateWithoutFinancialRegistrationInput[] | ExpenseUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutFinancialRegistrationInput | ExpenseCreateOrConnectWithoutFinancialRegistrationInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutFinancialRegistrationInput | ExpenseUpsertWithWhereUniqueWithoutFinancialRegistrationInput[]
    createMany?: ExpenseCreateManyFinancialRegistrationInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutFinancialRegistrationInput | ExpenseUpdateWithWhereUniqueWithoutFinancialRegistrationInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutFinancialRegistrationInput | ExpenseUpdateManyWithWhereWithoutFinancialRegistrationInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutFinancialRegistrationNestedInput = {
    create?: XOR<UserCreateWithoutFinancialRegistrationInput, UserUncheckedCreateWithoutFinancialRegistrationInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialRegistrationInput
    upsert?: UserUpsertWithoutFinancialRegistrationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFinancialRegistrationInput, UserUpdateWithoutFinancialRegistrationInput>, UserUncheckedUpdateWithoutFinancialRegistrationInput>
  }

  export type ReceivableUpdateManyWithoutFinancialRegistrationNestedInput = {
    create?: XOR<ReceivableCreateWithoutFinancialRegistrationInput, ReceivableUncheckedCreateWithoutFinancialRegistrationInput> | ReceivableCreateWithoutFinancialRegistrationInput[] | ReceivableUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutFinancialRegistrationInput | ReceivableCreateOrConnectWithoutFinancialRegistrationInput[]
    upsert?: ReceivableUpsertWithWhereUniqueWithoutFinancialRegistrationInput | ReceivableUpsertWithWhereUniqueWithoutFinancialRegistrationInput[]
    createMany?: ReceivableCreateManyFinancialRegistrationInputEnvelope
    set?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    disconnect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    delete?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    update?: ReceivableUpdateWithWhereUniqueWithoutFinancialRegistrationInput | ReceivableUpdateWithWhereUniqueWithoutFinancialRegistrationInput[]
    updateMany?: ReceivableUpdateManyWithWhereWithoutFinancialRegistrationInput | ReceivableUpdateManyWithWhereWithoutFinancialRegistrationInput[]
    deleteMany?: ReceivableScalarWhereInput | ReceivableScalarWhereInput[]
  }

  export type ExtraExpenseUpdateManyWithoutFinancialRegistrationNestedInput = {
    create?: XOR<ExtraExpenseCreateWithoutFinancialRegistrationInput, ExtraExpenseUncheckedCreateWithoutFinancialRegistrationInput> | ExtraExpenseCreateWithoutFinancialRegistrationInput[] | ExtraExpenseUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ExtraExpenseCreateOrConnectWithoutFinancialRegistrationInput | ExtraExpenseCreateOrConnectWithoutFinancialRegistrationInput[]
    upsert?: ExtraExpenseUpsertWithWhereUniqueWithoutFinancialRegistrationInput | ExtraExpenseUpsertWithWhereUniqueWithoutFinancialRegistrationInput[]
    createMany?: ExtraExpenseCreateManyFinancialRegistrationInputEnvelope
    set?: ExtraExpenseWhereUniqueInput | ExtraExpenseWhereUniqueInput[]
    disconnect?: ExtraExpenseWhereUniqueInput | ExtraExpenseWhereUniqueInput[]
    delete?: ExtraExpenseWhereUniqueInput | ExtraExpenseWhereUniqueInput[]
    connect?: ExtraExpenseWhereUniqueInput | ExtraExpenseWhereUniqueInput[]
    update?: ExtraExpenseUpdateWithWhereUniqueWithoutFinancialRegistrationInput | ExtraExpenseUpdateWithWhereUniqueWithoutFinancialRegistrationInput[]
    updateMany?: ExtraExpenseUpdateManyWithWhereWithoutFinancialRegistrationInput | ExtraExpenseUpdateManyWithWhereWithoutFinancialRegistrationInput[]
    deleteMany?: ExtraExpenseScalarWhereInput | ExtraExpenseScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutFinancialRegistrationNestedInput = {
    create?: XOR<ClientCreateWithoutFinancialRegistrationInput, ClientUncheckedCreateWithoutFinancialRegistrationInput> | ClientCreateWithoutFinancialRegistrationInput[] | ClientUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutFinancialRegistrationInput | ClientCreateOrConnectWithoutFinancialRegistrationInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutFinancialRegistrationInput | ClientUpsertWithWhereUniqueWithoutFinancialRegistrationInput[]
    createMany?: ClientCreateManyFinancialRegistrationInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutFinancialRegistrationInput | ClientUpdateWithWhereUniqueWithoutFinancialRegistrationInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutFinancialRegistrationInput | ClientUpdateManyWithWhereWithoutFinancialRegistrationInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutFinancialRegistrationNestedInput = {
    create?: XOR<ExpenseCreateWithoutFinancialRegistrationInput, ExpenseUncheckedCreateWithoutFinancialRegistrationInput> | ExpenseCreateWithoutFinancialRegistrationInput[] | ExpenseUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutFinancialRegistrationInput | ExpenseCreateOrConnectWithoutFinancialRegistrationInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutFinancialRegistrationInput | ExpenseUpsertWithWhereUniqueWithoutFinancialRegistrationInput[]
    createMany?: ExpenseCreateManyFinancialRegistrationInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutFinancialRegistrationInput | ExpenseUpdateWithWhereUniqueWithoutFinancialRegistrationInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutFinancialRegistrationInput | ExpenseUpdateManyWithWhereWithoutFinancialRegistrationInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ReceivableUncheckedUpdateManyWithoutFinancialRegistrationNestedInput = {
    create?: XOR<ReceivableCreateWithoutFinancialRegistrationInput, ReceivableUncheckedCreateWithoutFinancialRegistrationInput> | ReceivableCreateWithoutFinancialRegistrationInput[] | ReceivableUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutFinancialRegistrationInput | ReceivableCreateOrConnectWithoutFinancialRegistrationInput[]
    upsert?: ReceivableUpsertWithWhereUniqueWithoutFinancialRegistrationInput | ReceivableUpsertWithWhereUniqueWithoutFinancialRegistrationInput[]
    createMany?: ReceivableCreateManyFinancialRegistrationInputEnvelope
    set?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    disconnect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    delete?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    update?: ReceivableUpdateWithWhereUniqueWithoutFinancialRegistrationInput | ReceivableUpdateWithWhereUniqueWithoutFinancialRegistrationInput[]
    updateMany?: ReceivableUpdateManyWithWhereWithoutFinancialRegistrationInput | ReceivableUpdateManyWithWhereWithoutFinancialRegistrationInput[]
    deleteMany?: ReceivableScalarWhereInput | ReceivableScalarWhereInput[]
  }

  export type ExtraExpenseUncheckedUpdateManyWithoutFinancialRegistrationNestedInput = {
    create?: XOR<ExtraExpenseCreateWithoutFinancialRegistrationInput, ExtraExpenseUncheckedCreateWithoutFinancialRegistrationInput> | ExtraExpenseCreateWithoutFinancialRegistrationInput[] | ExtraExpenseUncheckedCreateWithoutFinancialRegistrationInput[]
    connectOrCreate?: ExtraExpenseCreateOrConnectWithoutFinancialRegistrationInput | ExtraExpenseCreateOrConnectWithoutFinancialRegistrationInput[]
    upsert?: ExtraExpenseUpsertWithWhereUniqueWithoutFinancialRegistrationInput | ExtraExpenseUpsertWithWhereUniqueWithoutFinancialRegistrationInput[]
    createMany?: ExtraExpenseCreateManyFinancialRegistrationInputEnvelope
    set?: ExtraExpenseWhereUniqueInput | ExtraExpenseWhereUniqueInput[]
    disconnect?: ExtraExpenseWhereUniqueInput | ExtraExpenseWhereUniqueInput[]
    delete?: ExtraExpenseWhereUniqueInput | ExtraExpenseWhereUniqueInput[]
    connect?: ExtraExpenseWhereUniqueInput | ExtraExpenseWhereUniqueInput[]
    update?: ExtraExpenseUpdateWithWhereUniqueWithoutFinancialRegistrationInput | ExtraExpenseUpdateWithWhereUniqueWithoutFinancialRegistrationInput[]
    updateMany?: ExtraExpenseUpdateManyWithWhereWithoutFinancialRegistrationInput | ExtraExpenseUpdateManyWithWhereWithoutFinancialRegistrationInput[]
    deleteMany?: ExtraExpenseScalarWhereInput | ExtraExpenseScalarWhereInput[]
  }

  export type FinancialRegistrationCreateNestedOneWithoutClientsInput = {
    create?: XOR<FinancialRegistrationCreateWithoutClientsInput, FinancialRegistrationUncheckedCreateWithoutClientsInput>
    connectOrCreate?: FinancialRegistrationCreateOrConnectWithoutClientsInput
    connect?: FinancialRegistrationWhereUniqueInput
  }

  export type ReceivableCreateNestedManyWithoutClientInput = {
    create?: XOR<ReceivableCreateWithoutClientInput, ReceivableUncheckedCreateWithoutClientInput> | ReceivableCreateWithoutClientInput[] | ReceivableUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutClientInput | ReceivableCreateOrConnectWithoutClientInput[]
    createMany?: ReceivableCreateManyClientInputEnvelope
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
  }

  export type ReceivableUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ReceivableCreateWithoutClientInput, ReceivableUncheckedCreateWithoutClientInput> | ReceivableCreateWithoutClientInput[] | ReceivableUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutClientInput | ReceivableCreateOrConnectWithoutClientInput[]
    createMany?: ReceivableCreateManyClientInputEnvelope
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
  }

  export type EnumClientTypeFieldUpdateOperationsInput = {
    set?: $Enums.ClientType
  }

  export type FinancialRegistrationUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<FinancialRegistrationCreateWithoutClientsInput, FinancialRegistrationUncheckedCreateWithoutClientsInput>
    connectOrCreate?: FinancialRegistrationCreateOrConnectWithoutClientsInput
    upsert?: FinancialRegistrationUpsertWithoutClientsInput
    connect?: FinancialRegistrationWhereUniqueInput
    update?: XOR<XOR<FinancialRegistrationUpdateToOneWithWhereWithoutClientsInput, FinancialRegistrationUpdateWithoutClientsInput>, FinancialRegistrationUncheckedUpdateWithoutClientsInput>
  }

  export type ReceivableUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReceivableCreateWithoutClientInput, ReceivableUncheckedCreateWithoutClientInput> | ReceivableCreateWithoutClientInput[] | ReceivableUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutClientInput | ReceivableCreateOrConnectWithoutClientInput[]
    upsert?: ReceivableUpsertWithWhereUniqueWithoutClientInput | ReceivableUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReceivableCreateManyClientInputEnvelope
    set?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    disconnect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    delete?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    update?: ReceivableUpdateWithWhereUniqueWithoutClientInput | ReceivableUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReceivableUpdateManyWithWhereWithoutClientInput | ReceivableUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReceivableScalarWhereInput | ReceivableScalarWhereInput[]
  }

  export type ReceivableUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReceivableCreateWithoutClientInput, ReceivableUncheckedCreateWithoutClientInput> | ReceivableCreateWithoutClientInput[] | ReceivableUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutClientInput | ReceivableCreateOrConnectWithoutClientInput[]
    upsert?: ReceivableUpsertWithWhereUniqueWithoutClientInput | ReceivableUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReceivableCreateManyClientInputEnvelope
    set?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    disconnect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    delete?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    update?: ReceivableUpdateWithWhereUniqueWithoutClientInput | ReceivableUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReceivableUpdateManyWithWhereWithoutClientInput | ReceivableUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReceivableScalarWhereInput | ReceivableScalarWhereInput[]
  }

  export type FinancialRegistrationCreateNestedOneWithoutExpensesInput = {
    create?: XOR<FinancialRegistrationCreateWithoutExpensesInput, FinancialRegistrationUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: FinancialRegistrationCreateOrConnectWithoutExpensesInput
    connect?: FinancialRegistrationWhereUniqueInput
  }

  export type EnumExpenseTypeFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type FinancialRegistrationUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<FinancialRegistrationCreateWithoutExpensesInput, FinancialRegistrationUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: FinancialRegistrationCreateOrConnectWithoutExpensesInput
    upsert?: FinancialRegistrationUpsertWithoutExpensesInput
    connect?: FinancialRegistrationWhereUniqueInput
    update?: XOR<XOR<FinancialRegistrationUpdateToOneWithWhereWithoutExpensesInput, FinancialRegistrationUpdateWithoutExpensesInput>, FinancialRegistrationUncheckedUpdateWithoutExpensesInput>
  }

  export type ClientCreateNestedOneWithoutReceivableInput = {
    create?: XOR<ClientCreateWithoutReceivableInput, ClientUncheckedCreateWithoutReceivableInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReceivableInput
    connect?: ClientWhereUniqueInput
  }

  export type FinancialRegistrationCreateNestedOneWithoutReceivableInput = {
    create?: XOR<FinancialRegistrationCreateWithoutReceivableInput, FinancialRegistrationUncheckedCreateWithoutReceivableInput>
    connectOrCreate?: FinancialRegistrationCreateOrConnectWithoutReceivableInput
    connect?: FinancialRegistrationWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutReceivableNestedInput = {
    create?: XOR<ClientCreateWithoutReceivableInput, ClientUncheckedCreateWithoutReceivableInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReceivableInput
    upsert?: ClientUpsertWithoutReceivableInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutReceivableInput, ClientUpdateWithoutReceivableInput>, ClientUncheckedUpdateWithoutReceivableInput>
  }

  export type FinancialRegistrationUpdateOneRequiredWithoutReceivableNestedInput = {
    create?: XOR<FinancialRegistrationCreateWithoutReceivableInput, FinancialRegistrationUncheckedCreateWithoutReceivableInput>
    connectOrCreate?: FinancialRegistrationCreateOrConnectWithoutReceivableInput
    upsert?: FinancialRegistrationUpsertWithoutReceivableInput
    connect?: FinancialRegistrationWhereUniqueInput
    update?: XOR<XOR<FinancialRegistrationUpdateToOneWithWhereWithoutReceivableInput, FinancialRegistrationUpdateWithoutReceivableInput>, FinancialRegistrationUncheckedUpdateWithoutReceivableInput>
  }

  export type FinancialRegistrationCreateNestedOneWithoutExtraExpenseInput = {
    create?: XOR<FinancialRegistrationCreateWithoutExtraExpenseInput, FinancialRegistrationUncheckedCreateWithoutExtraExpenseInput>
    connectOrCreate?: FinancialRegistrationCreateOrConnectWithoutExtraExpenseInput
    connect?: FinancialRegistrationWhereUniqueInput
  }

  export type FinancialRegistrationUpdateOneRequiredWithoutExtraExpenseNestedInput = {
    create?: XOR<FinancialRegistrationCreateWithoutExtraExpenseInput, FinancialRegistrationUncheckedCreateWithoutExtraExpenseInput>
    connectOrCreate?: FinancialRegistrationCreateOrConnectWithoutExtraExpenseInput
    upsert?: FinancialRegistrationUpsertWithoutExtraExpenseInput
    connect?: FinancialRegistrationWhereUniqueInput
    update?: XOR<XOR<FinancialRegistrationUpdateToOneWithWhereWithoutExtraExpenseInput, FinancialRegistrationUpdateWithoutExtraExpenseInput>, FinancialRegistrationUncheckedUpdateWithoutExtraExpenseInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumPrivacyFilter<$PrismaModel = never> = {
    equals?: $Enums.Privacy | EnumPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.Privacy[] | ListEnumPrivacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Privacy[] | ListEnumPrivacyFieldRefInput<$PrismaModel>
    not?: NestedEnumPrivacyFilter<$PrismaModel> | $Enums.Privacy
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumPrivacyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Privacy | EnumPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.Privacy[] | ListEnumPrivacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Privacy[] | ListEnumPrivacyFieldRefInput<$PrismaModel>
    not?: NestedEnumPrivacyWithAggregatesFilter<$PrismaModel> | $Enums.Privacy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrivacyFilter<$PrismaModel>
    _max?: NestedEnumPrivacyFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type NestedEnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type NestedEnumExpenseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseTypeFilter<$PrismaModel> | $Enums.ExpenseType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumExpenseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseType[] | ListEnumExpenseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseTypeFilter<$PrismaModel>
    _max?: NestedEnumExpenseTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type RoomCreateWithoutUsersInput = {
    id?: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    chats?: ChatCreateNestedManyWithoutRoomInput
    owner?: UserCreateNestedOneWithoutOwnedRoomsInput
    VideoRoom?: VideoRoomCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    ownerId: string
    updatedAt?: Date | string
    createdAt?: Date | string
    chats?: ChatUncheckedCreateNestedManyWithoutRoomInput
    VideoRoom?: VideoRoomUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutUsersInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutUsersInput, RoomUncheckedCreateWithoutUsersInput>
  }

  export type RoomCreateWithoutOwnerInput = {
    id?: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    chats?: ChatCreateNestedManyWithoutRoomInput
    users?: UserCreateNestedManyWithoutRoomsInput
    VideoRoom?: VideoRoomCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    chats?: ChatUncheckedCreateNestedManyWithoutRoomInput
    users?: UserUncheckedCreateNestedManyWithoutRoomsInput
    VideoRoom?: VideoRoomUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutOwnerInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput>
  }

  export type RoomCreateManyOwnerInputEnvelope = {
    data: RoomCreateManyOwnerInput | RoomCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectsCreateWithoutUsersInput = {
    id?: string
    name: string
    color: string
    usersIds?: ProjectsCreateusersIdsInput | string[]
    privacy?: $Enums.Privacy
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectsUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    color: string
    ownerId: string
    usersIds?: ProjectsCreateusersIdsInput | string[]
    privacy?: $Enums.Privacy
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectsCreateOrConnectWithoutUsersInput = {
    where: ProjectsWhereUniqueInput
    create: XOR<ProjectsCreateWithoutUsersInput, ProjectsUncheckedCreateWithoutUsersInput>
  }

  export type MessageCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    chatId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateManyUserInputEnvelope = {
    data: MessageCreateManyUserInput | MessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectsCreateWithoutOwnerInput = {
    id?: string
    name: string
    color: string
    usersIds?: ProjectsCreateusersIdsInput | string[]
    privacy?: $Enums.Privacy
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectsUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    color: string
    usersIds?: ProjectsCreateusersIdsInput | string[]
    privacy?: $Enums.Privacy
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutProjectsInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectsCreateOrConnectWithoutOwnerInput = {
    where: ProjectsWhereUniqueInput
    create: XOR<ProjectsCreateWithoutOwnerInput, ProjectsUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectsCreateManyOwnerInputEnvelope = {
    data: ProjectsCreateManyOwnerInput | ProjectsCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutResponsibleInput = {
    id?: string
    title: string
    information: string
    files: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectsCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutResponsibleInput = {
    id?: string
    title: string
    information: string
    files: string
    status?: $Enums.Status
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutResponsibleInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutResponsibleInput, TaskUncheckedCreateWithoutResponsibleInput>
  }

  export type TaskCreateManyResponsibleInputEnvelope = {
    data: TaskCreateManyResponsibleInput | TaskCreateManyResponsibleInput[]
    skipDuplicates?: boolean
  }

  export type AnnotationCreateWithoutUserInput = {
    id?: string
    title: string
    color: string
    information: string
  }

  export type AnnotationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    color: string
    information: string
  }

  export type AnnotationCreateOrConnectWithoutUserInput = {
    where: AnnotationWhereUniqueInput
    create: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput>
  }

  export type AnnotationCreateManyUserInputEnvelope = {
    data: AnnotationCreateManyUserInput | AnnotationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailTokenCreateWithoutUserInput = {
    id?: string
    token: string
    validated?: boolean
    attempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    validated?: boolean
    attempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTokenCreateOrConnectWithoutUserInput = {
    where: EmailTokenWhereUniqueInput
    create: XOR<EmailTokenCreateWithoutUserInput, EmailTokenUncheckedCreateWithoutUserInput>
  }

  export type EmailTokenCreateManyUserInputEnvelope = {
    data: EmailTokenCreateManyUserInput | EmailTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSendNotificationInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    senderId: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutSenderInput = {
    id?: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutSenderInput = {
    id?: string
    userId: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationCreateManySenderInputEnvelope = {
    data: NotificationCreateManySenderInput | NotificationCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type VideoRoomCreateWithoutOwnerInput = {
    id?: string
    roomLink: string
    room: RoomCreateNestedOneWithoutVideoRoomInput
  }

  export type VideoRoomUncheckedCreateWithoutOwnerInput = {
    id?: string
    roomId: string
    roomLink: string
  }

  export type VideoRoomCreateOrConnectWithoutOwnerInput = {
    where: VideoRoomWhereUniqueInput
    create: XOR<VideoRoomCreateWithoutOwnerInput, VideoRoomUncheckedCreateWithoutOwnerInput>
  }

  export type VideoRoomCreateManyOwnerInputEnvelope = {
    data: VideoRoomCreateManyOwnerInput | VideoRoomCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type FinancialRegistrationCreateWithoutUserInput = {
    id?: string
    clients?: ClientCreateNestedManyWithoutFinancialRegistrationInput
    expenses?: ExpenseCreateNestedManyWithoutFinancialRegistrationInput
    Receivable?: ReceivableCreateNestedManyWithoutFinancialRegistrationInput
    ExtraExpense?: ExtraExpenseCreateNestedManyWithoutFinancialRegistrationInput
  }

  export type FinancialRegistrationUncheckedCreateWithoutUserInput = {
    id?: string
    clients?: ClientUncheckedCreateNestedManyWithoutFinancialRegistrationInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutFinancialRegistrationInput
    Receivable?: ReceivableUncheckedCreateNestedManyWithoutFinancialRegistrationInput
    ExtraExpense?: ExtraExpenseUncheckedCreateNestedManyWithoutFinancialRegistrationInput
  }

  export type FinancialRegistrationCreateOrConnectWithoutUserInput = {
    where: FinancialRegistrationWhereUniqueInput
    create: XOR<FinancialRegistrationCreateWithoutUserInput, FinancialRegistrationUncheckedCreateWithoutUserInput>
  }

  export type FinancialRegistrationCreateManyUserInputEnvelope = {
    data: FinancialRegistrationCreateManyUserInput | FinancialRegistrationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoomUpsertWithWhereUniqueWithoutUsersInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutUsersInput, RoomUncheckedUpdateWithoutUsersInput>
    create: XOR<RoomCreateWithoutUsersInput, RoomUncheckedCreateWithoutUsersInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutUsersInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutUsersInput, RoomUncheckedUpdateWithoutUsersInput>
  }

  export type RoomUpdateManyWithWhereWithoutUsersInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutUsersInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    ownerId?: StringFilter<"Room"> | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
  }

  export type RoomUpsertWithWhereUniqueWithoutOwnerInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutOwnerInput, RoomUncheckedUpdateWithoutOwnerInput>
    create: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutOwnerInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutOwnerInput, RoomUncheckedUpdateWithoutOwnerInput>
  }

  export type RoomUpdateManyWithWhereWithoutOwnerInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ProjectsUpsertWithWhereUniqueWithoutUsersInput = {
    where: ProjectsWhereUniqueInput
    update: XOR<ProjectsUpdateWithoutUsersInput, ProjectsUncheckedUpdateWithoutUsersInput>
    create: XOR<ProjectsCreateWithoutUsersInput, ProjectsUncheckedCreateWithoutUsersInput>
  }

  export type ProjectsUpdateWithWhereUniqueWithoutUsersInput = {
    where: ProjectsWhereUniqueInput
    data: XOR<ProjectsUpdateWithoutUsersInput, ProjectsUncheckedUpdateWithoutUsersInput>
  }

  export type ProjectsUpdateManyWithWhereWithoutUsersInput = {
    where: ProjectsScalarWhereInput
    data: XOR<ProjectsUpdateManyMutationInput, ProjectsUncheckedUpdateManyWithoutUsersInput>
  }

  export type ProjectsScalarWhereInput = {
    AND?: ProjectsScalarWhereInput | ProjectsScalarWhereInput[]
    OR?: ProjectsScalarWhereInput[]
    NOT?: ProjectsScalarWhereInput | ProjectsScalarWhereInput[]
    id?: StringFilter<"Projects"> | string
    name?: StringFilter<"Projects"> | string
    color?: StringFilter<"Projects"> | string
    ownerId?: StringFilter<"Projects"> | string
    usersIds?: StringNullableListFilter<"Projects">
    privacy?: EnumPrivacyFilter<"Projects"> | $Enums.Privacy
    createdAt?: DateTimeFilter<"Projects"> | Date | string
    updatedAt?: DateTimeFilter<"Projects"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    userId?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type ProjectsUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ProjectsWhereUniqueInput
    update: XOR<ProjectsUpdateWithoutOwnerInput, ProjectsUncheckedUpdateWithoutOwnerInput>
    create: XOR<ProjectsCreateWithoutOwnerInput, ProjectsUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectsUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ProjectsWhereUniqueInput
    data: XOR<ProjectsUpdateWithoutOwnerInput, ProjectsUncheckedUpdateWithoutOwnerInput>
  }

  export type ProjectsUpdateManyWithWhereWithoutOwnerInput = {
    where: ProjectsScalarWhereInput
    data: XOR<ProjectsUpdateManyMutationInput, ProjectsUncheckedUpdateManyWithoutOwnerInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutResponsibleInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutResponsibleInput, TaskUncheckedUpdateWithoutResponsibleInput>
    create: XOR<TaskCreateWithoutResponsibleInput, TaskUncheckedCreateWithoutResponsibleInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutResponsibleInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutResponsibleInput, TaskUncheckedUpdateWithoutResponsibleInput>
  }

  export type TaskUpdateManyWithWhereWithoutResponsibleInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutResponsibleInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    information?: StringFilter<"Task"> | string
    files?: StringFilter<"Task"> | string
    status?: EnumStatusFilter<"Task"> | $Enums.Status
    projectId?: StringFilter<"Task"> | string
    responsibleId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type AnnotationUpsertWithWhereUniqueWithoutUserInput = {
    where: AnnotationWhereUniqueInput
    update: XOR<AnnotationUpdateWithoutUserInput, AnnotationUncheckedUpdateWithoutUserInput>
    create: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput>
  }

  export type AnnotationUpdateWithWhereUniqueWithoutUserInput = {
    where: AnnotationWhereUniqueInput
    data: XOR<AnnotationUpdateWithoutUserInput, AnnotationUncheckedUpdateWithoutUserInput>
  }

  export type AnnotationUpdateManyWithWhereWithoutUserInput = {
    where: AnnotationScalarWhereInput
    data: XOR<AnnotationUpdateManyMutationInput, AnnotationUncheckedUpdateManyWithoutUserInput>
  }

  export type AnnotationScalarWhereInput = {
    AND?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
    OR?: AnnotationScalarWhereInput[]
    NOT?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
    id?: StringFilter<"Annotation"> | string
    userId?: StringFilter<"Annotation"> | string
    title?: StringFilter<"Annotation"> | string
    color?: StringFilter<"Annotation"> | string
    information?: StringFilter<"Annotation"> | string
  }

  export type EmailTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailTokenWhereUniqueInput
    update: XOR<EmailTokenUpdateWithoutUserInput, EmailTokenUncheckedUpdateWithoutUserInput>
    create: XOR<EmailTokenCreateWithoutUserInput, EmailTokenUncheckedCreateWithoutUserInput>
  }

  export type EmailTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailTokenWhereUniqueInput
    data: XOR<EmailTokenUpdateWithoutUserInput, EmailTokenUncheckedUpdateWithoutUserInput>
  }

  export type EmailTokenUpdateManyWithWhereWithoutUserInput = {
    where: EmailTokenScalarWhereInput
    data: XOR<EmailTokenUpdateManyMutationInput, EmailTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailTokenScalarWhereInput = {
    AND?: EmailTokenScalarWhereInput | EmailTokenScalarWhereInput[]
    OR?: EmailTokenScalarWhereInput[]
    NOT?: EmailTokenScalarWhereInput | EmailTokenScalarWhereInput[]
    id?: StringFilter<"EmailToken"> | string
    email?: StringFilter<"EmailToken"> | string
    token?: StringFilter<"EmailToken"> | string
    validated?: BoolFilter<"EmailToken"> | boolean
    attempts?: IntFilter<"EmailToken"> | number
    createdAt?: DateTimeFilter<"EmailToken"> | Date | string
    updatedAt?: DateTimeFilter<"EmailToken"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    senderId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
  }

  export type NotificationUpdateManyWithWhereWithoutSenderInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutSenderInput>
  }

  export type VideoRoomUpsertWithWhereUniqueWithoutOwnerInput = {
    where: VideoRoomWhereUniqueInput
    update: XOR<VideoRoomUpdateWithoutOwnerInput, VideoRoomUncheckedUpdateWithoutOwnerInput>
    create: XOR<VideoRoomCreateWithoutOwnerInput, VideoRoomUncheckedCreateWithoutOwnerInput>
  }

  export type VideoRoomUpdateWithWhereUniqueWithoutOwnerInput = {
    where: VideoRoomWhereUniqueInput
    data: XOR<VideoRoomUpdateWithoutOwnerInput, VideoRoomUncheckedUpdateWithoutOwnerInput>
  }

  export type VideoRoomUpdateManyWithWhereWithoutOwnerInput = {
    where: VideoRoomScalarWhereInput
    data: XOR<VideoRoomUpdateManyMutationInput, VideoRoomUncheckedUpdateManyWithoutOwnerInput>
  }

  export type VideoRoomScalarWhereInput = {
    AND?: VideoRoomScalarWhereInput | VideoRoomScalarWhereInput[]
    OR?: VideoRoomScalarWhereInput[]
    NOT?: VideoRoomScalarWhereInput | VideoRoomScalarWhereInput[]
    id?: StringFilter<"VideoRoom"> | string
    ownerId?: StringFilter<"VideoRoom"> | string
    roomId?: StringFilter<"VideoRoom"> | string
    roomLink?: StringFilter<"VideoRoom"> | string
  }

  export type FinancialRegistrationUpsertWithWhereUniqueWithoutUserInput = {
    where: FinancialRegistrationWhereUniqueInput
    update: XOR<FinancialRegistrationUpdateWithoutUserInput, FinancialRegistrationUncheckedUpdateWithoutUserInput>
    create: XOR<FinancialRegistrationCreateWithoutUserInput, FinancialRegistrationUncheckedCreateWithoutUserInput>
  }

  export type FinancialRegistrationUpdateWithWhereUniqueWithoutUserInput = {
    where: FinancialRegistrationWhereUniqueInput
    data: XOR<FinancialRegistrationUpdateWithoutUserInput, FinancialRegistrationUncheckedUpdateWithoutUserInput>
  }

  export type FinancialRegistrationUpdateManyWithWhereWithoutUserInput = {
    where: FinancialRegistrationScalarWhereInput
    data: XOR<FinancialRegistrationUpdateManyMutationInput, FinancialRegistrationUncheckedUpdateManyWithoutUserInput>
  }

  export type FinancialRegistrationScalarWhereInput = {
    AND?: FinancialRegistrationScalarWhereInput | FinancialRegistrationScalarWhereInput[]
    OR?: FinancialRegistrationScalarWhereInput[]
    NOT?: FinancialRegistrationScalarWhereInput | FinancialRegistrationScalarWhereInput[]
    id?: StringFilter<"FinancialRegistration"> | string
    userId?: StringFilter<"FinancialRegistration"> | string
  }

  export type UserCreateWithoutAnnotationInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutResponsibleInput
    emailToken?: EmailTokenCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    sendNotification?: NotificationCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnnotationInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomUncheckedCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutResponsibleInput
    emailToken?: EmailTokenUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sendNotification?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomUncheckedCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnnotationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnotationInput, UserUncheckedCreateWithoutAnnotationInput>
  }

  export type UserUpsertWithoutAnnotationInput = {
    update: XOR<UserUpdateWithoutAnnotationInput, UserUncheckedUpdateWithoutAnnotationInput>
    create: XOR<UserCreateWithoutAnnotationInput, UserUncheckedCreateWithoutAnnotationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnotationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnotationInput, UserUncheckedUpdateWithoutAnnotationInput>
  }

  export type UserUpdateWithoutAnnotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutResponsibleNestedInput
    emailToken?: EmailTokenUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUncheckedUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutResponsibleNestedInput
    emailToken?: EmailTokenUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUncheckedUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    messages?: MessageCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    sendNotification?: NotificationCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomUncheckedCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sendNotification?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomUncheckedCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type UserCreateWithoutOwnedProjectsInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    sendNotification?: NotificationCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedProjectsInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomUncheckedCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sendNotification?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomUncheckedCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
  }

  export type TaskCreateWithoutProjectInput = {
    id?: string
    title: string
    information: string
    files: string
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    responsible?: UserCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    information: string
    files: string
    status?: $Enums.Status
    responsibleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskCreateManyProjectInputEnvelope = {
    data: TaskCreateManyProjectInput | TaskCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutProjectsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutProjectsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateManyWithWhereWithoutProjectsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutProjectsInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    gender?: StringFilter<"User"> | string
    dateBirth?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
  }

  export type UserUpsertWithoutOwnedProjectsInput = {
    update: XOR<UserUpdateWithoutOwnedProjectsInput, UserUncheckedUpdateWithoutOwnedProjectsInput>
    create: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedProjectsInput, UserUncheckedUpdateWithoutOwnedProjectsInput>
  }

  export type UserUpdateWithoutOwnedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUncheckedUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUncheckedUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
  }

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutProjectInput>
  }

  export type UserCreateWithoutTasksInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsCreateNestedManyWithoutOwnerInput
    annotation?: AnnotationCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    sendNotification?: NotificationCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasksInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomUncheckedCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsUncheckedCreateNestedManyWithoutOwnerInput
    annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sendNotification?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomUncheckedCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
  }

  export type ProjectsCreateWithoutTasksInput = {
    id?: string
    name: string
    color: string
    usersIds?: ProjectsCreateusersIdsInput | string[]
    privacy?: $Enums.Privacy
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutProjectsInput
    owner?: UserCreateNestedOneWithoutOwnedProjectsInput
  }

  export type ProjectsUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    color: string
    ownerId: string
    usersIds?: ProjectsCreateusersIdsInput | string[]
    privacy?: $Enums.Privacy
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsCreateOrConnectWithoutTasksInput = {
    where: ProjectsWhereUniqueInput
    create: XOR<ProjectsCreateWithoutTasksInput, ProjectsUncheckedCreateWithoutTasksInput>
  }

  export type UserUpsertWithoutTasksInput = {
    update: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUpdateManyWithoutOwnerNestedInput
    annotation?: AnnotationUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUncheckedUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUncheckedUpdateManyWithoutOwnerNestedInput
    annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUncheckedUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectsUpsertWithoutTasksInput = {
    update: XOR<ProjectsUpdateWithoutTasksInput, ProjectsUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectsCreateWithoutTasksInput, ProjectsUncheckedCreateWithoutTasksInput>
    where?: ProjectsWhereInput
  }

  export type ProjectsUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectsWhereInput
    data: XOR<ProjectsUpdateWithoutTasksInput, ProjectsUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectsUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    usersIds?: ProjectsUpdateusersIdsInput | string[]
    privacy?: EnumPrivacyFieldUpdateOperationsInput | $Enums.Privacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutProjectsNestedInput
    owner?: UserUpdateOneWithoutOwnedProjectsNestedInput
  }

  export type ProjectsUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    usersIds?: ProjectsUpdateusersIdsInput | string[]
    privacy?: EnumPrivacyFieldUpdateOperationsInput | $Enums.Privacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ChatCreateWithoutRoomInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutRoomInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutRoomInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutRoomInput, ChatUncheckedCreateWithoutRoomInput>
  }

  export type ChatCreateManyRoomInputEnvelope = {
    data: ChatCreateManyRoomInput | ChatCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRoomsInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    sendNotification?: NotificationCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoomsInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sendNotification?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomUncheckedCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoomsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoomsInput, UserUncheckedCreateWithoutRoomsInput>
  }

  export type UserCreateWithoutOwnedRoomsInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomCreateNestedManyWithoutUsersInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    sendNotification?: NotificationCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedRoomsInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomUncheckedCreateNestedManyWithoutUsersInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sendNotification?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomUncheckedCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedRoomsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedRoomsInput, UserUncheckedCreateWithoutOwnedRoomsInput>
  }

  export type VideoRoomCreateWithoutRoomInput = {
    id?: string
    roomLink: string
    owner: UserCreateNestedOneWithoutVideoRoomInput
  }

  export type VideoRoomUncheckedCreateWithoutRoomInput = {
    id?: string
    ownerId: string
    roomLink: string
  }

  export type VideoRoomCreateOrConnectWithoutRoomInput = {
    where: VideoRoomWhereUniqueInput
    create: XOR<VideoRoomCreateWithoutRoomInput, VideoRoomUncheckedCreateWithoutRoomInput>
  }

  export type VideoRoomCreateManyRoomInputEnvelope = {
    data: VideoRoomCreateManyRoomInput | VideoRoomCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type ChatUpsertWithWhereUniqueWithoutRoomInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutRoomInput, ChatUncheckedUpdateWithoutRoomInput>
    create: XOR<ChatCreateWithoutRoomInput, ChatUncheckedCreateWithoutRoomInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutRoomInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutRoomInput, ChatUncheckedUpdateWithoutRoomInput>
  }

  export type ChatUpdateManyWithWhereWithoutRoomInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutRoomInput>
  }

  export type ChatScalarWhereInput = {
    AND?: ChatScalarWhereInput | ChatScalarWhereInput[]
    OR?: ChatScalarWhereInput[]
    NOT?: ChatScalarWhereInput | ChatScalarWhereInput[]
    id?: StringFilter<"Chat"> | string
    roomId?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutRoomsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoomsInput, UserUncheckedUpdateWithoutRoomsInput>
    create: XOR<UserCreateWithoutRoomsInput, UserUncheckedCreateWithoutRoomsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoomsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoomsInput, UserUncheckedUpdateWithoutRoomsInput>
  }

  export type UserUpdateManyWithWhereWithoutRoomsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoomsInput>
  }

  export type UserUpsertWithoutOwnedRoomsInput = {
    update: XOR<UserUpdateWithoutOwnedRoomsInput, UserUncheckedUpdateWithoutOwnedRoomsInput>
    create: XOR<UserCreateWithoutOwnedRoomsInput, UserUncheckedCreateWithoutOwnedRoomsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedRoomsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedRoomsInput, UserUncheckedUpdateWithoutOwnedRoomsInput>
  }

  export type UserUpdateWithoutOwnedRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUncheckedUpdateManyWithoutUsersNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUncheckedUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VideoRoomUpsertWithWhereUniqueWithoutRoomInput = {
    where: VideoRoomWhereUniqueInput
    update: XOR<VideoRoomUpdateWithoutRoomInput, VideoRoomUncheckedUpdateWithoutRoomInput>
    create: XOR<VideoRoomCreateWithoutRoomInput, VideoRoomUncheckedCreateWithoutRoomInput>
  }

  export type VideoRoomUpdateWithWhereUniqueWithoutRoomInput = {
    where: VideoRoomWhereUniqueInput
    data: XOR<VideoRoomUpdateWithoutRoomInput, VideoRoomUncheckedUpdateWithoutRoomInput>
  }

  export type VideoRoomUpdateManyWithWhereWithoutRoomInput = {
    where: VideoRoomScalarWhereInput
    data: XOR<VideoRoomUpdateManyMutationInput, VideoRoomUncheckedUpdateManyWithoutRoomInput>
  }

  export type RoomCreateWithoutVideoRoomInput = {
    id?: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    chats?: ChatCreateNestedManyWithoutRoomInput
    users?: UserCreateNestedManyWithoutRoomsInput
    owner?: UserCreateNestedOneWithoutOwnedRoomsInput
  }

  export type RoomUncheckedCreateWithoutVideoRoomInput = {
    id?: string
    name: string
    ownerId: string
    updatedAt?: Date | string
    createdAt?: Date | string
    chats?: ChatUncheckedCreateNestedManyWithoutRoomInput
    users?: UserUncheckedCreateNestedManyWithoutRoomsInput
  }

  export type RoomCreateOrConnectWithoutVideoRoomInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutVideoRoomInput, RoomUncheckedCreateWithoutVideoRoomInput>
  }

  export type UserCreateWithoutVideoRoomInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    sendNotification?: NotificationCreateNestedManyWithoutSenderInput
    financialRegistration?: FinancialRegistrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVideoRoomInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomUncheckedCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sendNotification?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    financialRegistration?: FinancialRegistrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVideoRoomInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVideoRoomInput, UserUncheckedCreateWithoutVideoRoomInput>
  }

  export type RoomUpsertWithoutVideoRoomInput = {
    update: XOR<RoomUpdateWithoutVideoRoomInput, RoomUncheckedUpdateWithoutVideoRoomInput>
    create: XOR<RoomCreateWithoutVideoRoomInput, RoomUncheckedCreateWithoutVideoRoomInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutVideoRoomInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutVideoRoomInput, RoomUncheckedUpdateWithoutVideoRoomInput>
  }

  export type RoomUpdateWithoutVideoRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chats?: ChatUpdateManyWithoutRoomNestedInput
    users?: UserUpdateManyWithoutRoomsNestedInput
    owner?: UserUpdateOneWithoutOwnedRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutVideoRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chats?: ChatUncheckedUpdateManyWithoutRoomNestedInput
    users?: UserUncheckedUpdateManyWithoutRoomsNestedInput
  }

  export type UserUpsertWithoutVideoRoomInput = {
    update: XOR<UserUpdateWithoutVideoRoomInput, UserUncheckedUpdateWithoutVideoRoomInput>
    create: XOR<UserCreateWithoutVideoRoomInput, UserUncheckedCreateWithoutVideoRoomInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVideoRoomInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVideoRoomInput, UserUncheckedUpdateWithoutVideoRoomInput>
  }

  export type UserUpdateWithoutVideoRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUpdateManyWithoutSenderNestedInput
    financialRegistration?: FinancialRegistrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVideoRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUncheckedUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    financialRegistration?: FinancialRegistrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageCreateWithoutChatInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutChatInput = {
    id?: string
    content: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutChatInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageCreateManyChatInputEnvelope = {
    data: MessageCreateManyChatInput | MessageCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type RoomCreateWithoutChatsInput = {
    id?: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutRoomsInput
    owner?: UserCreateNestedOneWithoutOwnedRoomsInput
    VideoRoom?: VideoRoomCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutChatsInput = {
    id?: string
    name: string
    ownerId: string
    updatedAt?: Date | string
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoomsInput
    VideoRoom?: VideoRoomUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutChatsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutChatsInput, RoomUncheckedCreateWithoutChatsInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
  }

  export type MessageUpdateManyWithWhereWithoutChatInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutChatInput>
  }

  export type RoomUpsertWithoutChatsInput = {
    update: XOR<RoomUpdateWithoutChatsInput, RoomUncheckedUpdateWithoutChatsInput>
    create: XOR<RoomCreateWithoutChatsInput, RoomUncheckedCreateWithoutChatsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutChatsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutChatsInput, RoomUncheckedUpdateWithoutChatsInput>
  }

  export type RoomUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoomsNestedInput
    owner?: UserUpdateOneWithoutOwnedRoomsNestedInput
    VideoRoom?: VideoRoomUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoomsNestedInput
    VideoRoom?: VideoRoomUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    ownedProjects?: ProjectsCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    sendNotification?: NotificationCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomUncheckedCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    ownedProjects?: ProjectsUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sendNotification?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomUncheckedCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type ChatCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutChatsInput
  }

  export type ChatUncheckedCreateWithoutMessagesInput = {
    id?: string
    roomId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateOrConnectWithoutMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    ownedProjects?: ProjectsUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUncheckedUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    ownedProjects?: ProjectsUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUncheckedUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChatUpsertWithoutMessagesInput = {
    update: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutEmailTokenInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    sendNotification?: NotificationCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailTokenInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomUncheckedCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sendNotification?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomUncheckedCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailTokenInput, UserUncheckedCreateWithoutEmailTokenInput>
  }

  export type UserUpsertWithoutEmailTokenInput = {
    update: XOR<UserUpdateWithoutEmailTokenInput, UserUncheckedUpdateWithoutEmailTokenInput>
    create: XOR<UserCreateWithoutEmailTokenInput, UserUncheckedCreateWithoutEmailTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailTokenInput, UserUncheckedUpdateWithoutEmailTokenInput>
  }

  export type UserUpdateWithoutEmailTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUncheckedUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUncheckedUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenCreateNestedManyWithoutUserInput
    sendNotification?: NotificationCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomUncheckedCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenUncheckedCreateNestedManyWithoutUserInput
    sendNotification?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomUncheckedCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserCreateWithoutSendNotificationInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    videoRoom?: VideoRoomCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSendNotificationInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomUncheckedCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    videoRoom?: VideoRoomUncheckedCreateNestedManyWithoutOwnerInput
    financialRegistration?: FinancialRegistrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSendNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSendNotificationInput, UserUncheckedCreateWithoutSendNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUncheckedUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUncheckedUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUncheckedUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutSendNotificationInput = {
    update: XOR<UserUpdateWithoutSendNotificationInput, UserUncheckedUpdateWithoutSendNotificationInput>
    create: XOR<UserCreateWithoutSendNotificationInput, UserUncheckedCreateWithoutSendNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSendNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSendNotificationInput, UserUncheckedUpdateWithoutSendNotificationInput>
  }

  export type UserUpdateWithoutSendNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    videoRoom?: VideoRoomUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSendNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUncheckedUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    videoRoom?: VideoRoomUncheckedUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClientCreateWithoutFinancialRegistrationInput = {
    id?: string
    name: string
    type: $Enums.ClientType
    address: string
    phone: string
    email: string
    Receivable?: ReceivableCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutFinancialRegistrationInput = {
    id?: string
    name: string
    type: $Enums.ClientType
    address: string
    phone: string
    email: string
    Receivable?: ReceivableUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutFinancialRegistrationInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutFinancialRegistrationInput, ClientUncheckedCreateWithoutFinancialRegistrationInput>
  }

  export type ClientCreateManyFinancialRegistrationInputEnvelope = {
    data: ClientCreateManyFinancialRegistrationInput | ClientCreateManyFinancialRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutFinancialRegistrationInput = {
    id?: string
    type: $Enums.ExpenseType
    amount: number
    recurringMonth: number
    contractStartDate: Date | string
    contractEndDate?: Date | string | null
  }

  export type ExpenseUncheckedCreateWithoutFinancialRegistrationInput = {
    id?: string
    type: $Enums.ExpenseType
    amount: number
    recurringMonth: number
    contractStartDate: Date | string
    contractEndDate?: Date | string | null
  }

  export type ExpenseCreateOrConnectWithoutFinancialRegistrationInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutFinancialRegistrationInput, ExpenseUncheckedCreateWithoutFinancialRegistrationInput>
  }

  export type ExpenseCreateManyFinancialRegistrationInputEnvelope = {
    data: ExpenseCreateManyFinancialRegistrationInput | ExpenseCreateManyFinancialRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutFinancialRegistrationInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    projects?: ProjectsCreateNestedManyWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsCreateNestedManyWithoutOwnerInput
    tasks?: TaskCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    sendNotification?: NotificationCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutFinancialRegistrationInput = {
    id?: string
    email: string
    name: string
    phone: string
    gender: string
    dateBirth: string
    password: string
    rooms?: RoomUncheckedCreateNestedManyWithoutUsersInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    projects?: ProjectsUncheckedCreateNestedManyWithoutUsersInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectsUncheckedCreateNestedManyWithoutOwnerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutResponsibleInput
    annotation?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    emailToken?: EmailTokenUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sendNotification?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    videoRoom?: VideoRoomUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutFinancialRegistrationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFinancialRegistrationInput, UserUncheckedCreateWithoutFinancialRegistrationInput>
  }

  export type ReceivableCreateWithoutFinancialRegistrationInput = {
    id?: string
    serviceProvided: string
    amountToReceive: number
    serviceStartDate: Date | string
    serviceEndDate: Date | string
    client: ClientCreateNestedOneWithoutReceivableInput
  }

  export type ReceivableUncheckedCreateWithoutFinancialRegistrationInput = {
    id?: string
    clientId: string
    serviceProvided: string
    amountToReceive: number
    serviceStartDate: Date | string
    serviceEndDate: Date | string
  }

  export type ReceivableCreateOrConnectWithoutFinancialRegistrationInput = {
    where: ReceivableWhereUniqueInput
    create: XOR<ReceivableCreateWithoutFinancialRegistrationInput, ReceivableUncheckedCreateWithoutFinancialRegistrationInput>
  }

  export type ReceivableCreateManyFinancialRegistrationInputEnvelope = {
    data: ReceivableCreateManyFinancialRegistrationInput | ReceivableCreateManyFinancialRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type ExtraExpenseCreateWithoutFinancialRegistrationInput = {
    id?: string
    expenseType: string
    amount: number
    startDate: Date | string
    endDate: Date | string
  }

  export type ExtraExpenseUncheckedCreateWithoutFinancialRegistrationInput = {
    id?: string
    expenseType: string
    amount: number
    startDate: Date | string
    endDate: Date | string
  }

  export type ExtraExpenseCreateOrConnectWithoutFinancialRegistrationInput = {
    where: ExtraExpenseWhereUniqueInput
    create: XOR<ExtraExpenseCreateWithoutFinancialRegistrationInput, ExtraExpenseUncheckedCreateWithoutFinancialRegistrationInput>
  }

  export type ExtraExpenseCreateManyFinancialRegistrationInputEnvelope = {
    data: ExtraExpenseCreateManyFinancialRegistrationInput | ExtraExpenseCreateManyFinancialRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithWhereUniqueWithoutFinancialRegistrationInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutFinancialRegistrationInput, ClientUncheckedUpdateWithoutFinancialRegistrationInput>
    create: XOR<ClientCreateWithoutFinancialRegistrationInput, ClientUncheckedCreateWithoutFinancialRegistrationInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutFinancialRegistrationInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutFinancialRegistrationInput, ClientUncheckedUpdateWithoutFinancialRegistrationInput>
  }

  export type ClientUpdateManyWithWhereWithoutFinancialRegistrationInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutFinancialRegistrationInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    type?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    address?: StringFilter<"Client"> | string
    phone?: StringFilter<"Client"> | string
    email?: StringFilter<"Client"> | string
    financialRegistrationId?: StringFilter<"Client"> | string
  }

  export type ExpenseUpsertWithWhereUniqueWithoutFinancialRegistrationInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutFinancialRegistrationInput, ExpenseUncheckedUpdateWithoutFinancialRegistrationInput>
    create: XOR<ExpenseCreateWithoutFinancialRegistrationInput, ExpenseUncheckedCreateWithoutFinancialRegistrationInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutFinancialRegistrationInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutFinancialRegistrationInput, ExpenseUncheckedUpdateWithoutFinancialRegistrationInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutFinancialRegistrationInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutFinancialRegistrationInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: StringFilter<"Expense"> | string
    type?: EnumExpenseTypeFilter<"Expense"> | $Enums.ExpenseType
    amount?: FloatFilter<"Expense"> | number
    recurringMonth?: IntFilter<"Expense"> | number
    contractStartDate?: DateTimeFilter<"Expense"> | Date | string
    contractEndDate?: DateTimeNullableFilter<"Expense"> | Date | string | null
    financialRegistrationId?: StringFilter<"Expense"> | string
  }

  export type UserUpsertWithoutFinancialRegistrationInput = {
    update: XOR<UserUpdateWithoutFinancialRegistrationInput, UserUncheckedUpdateWithoutFinancialRegistrationInput>
    create: XOR<UserCreateWithoutFinancialRegistrationInput, UserUncheckedCreateWithoutFinancialRegistrationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFinancialRegistrationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFinancialRegistrationInput, UserUncheckedUpdateWithoutFinancialRegistrationInput>
  }

  export type UserUpdateWithoutFinancialRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutFinancialRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUncheckedUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type ReceivableUpsertWithWhereUniqueWithoutFinancialRegistrationInput = {
    where: ReceivableWhereUniqueInput
    update: XOR<ReceivableUpdateWithoutFinancialRegistrationInput, ReceivableUncheckedUpdateWithoutFinancialRegistrationInput>
    create: XOR<ReceivableCreateWithoutFinancialRegistrationInput, ReceivableUncheckedCreateWithoutFinancialRegistrationInput>
  }

  export type ReceivableUpdateWithWhereUniqueWithoutFinancialRegistrationInput = {
    where: ReceivableWhereUniqueInput
    data: XOR<ReceivableUpdateWithoutFinancialRegistrationInput, ReceivableUncheckedUpdateWithoutFinancialRegistrationInput>
  }

  export type ReceivableUpdateManyWithWhereWithoutFinancialRegistrationInput = {
    where: ReceivableScalarWhereInput
    data: XOR<ReceivableUpdateManyMutationInput, ReceivableUncheckedUpdateManyWithoutFinancialRegistrationInput>
  }

  export type ReceivableScalarWhereInput = {
    AND?: ReceivableScalarWhereInput | ReceivableScalarWhereInput[]
    OR?: ReceivableScalarWhereInput[]
    NOT?: ReceivableScalarWhereInput | ReceivableScalarWhereInput[]
    id?: StringFilter<"Receivable"> | string
    clientId?: StringFilter<"Receivable"> | string
    serviceProvided?: StringFilter<"Receivable"> | string
    amountToReceive?: FloatFilter<"Receivable"> | number
    serviceStartDate?: DateTimeFilter<"Receivable"> | Date | string
    serviceEndDate?: DateTimeFilter<"Receivable"> | Date | string
    financialRegistrationId?: StringFilter<"Receivable"> | string
  }

  export type ExtraExpenseUpsertWithWhereUniqueWithoutFinancialRegistrationInput = {
    where: ExtraExpenseWhereUniqueInput
    update: XOR<ExtraExpenseUpdateWithoutFinancialRegistrationInput, ExtraExpenseUncheckedUpdateWithoutFinancialRegistrationInput>
    create: XOR<ExtraExpenseCreateWithoutFinancialRegistrationInput, ExtraExpenseUncheckedCreateWithoutFinancialRegistrationInput>
  }

  export type ExtraExpenseUpdateWithWhereUniqueWithoutFinancialRegistrationInput = {
    where: ExtraExpenseWhereUniqueInput
    data: XOR<ExtraExpenseUpdateWithoutFinancialRegistrationInput, ExtraExpenseUncheckedUpdateWithoutFinancialRegistrationInput>
  }

  export type ExtraExpenseUpdateManyWithWhereWithoutFinancialRegistrationInput = {
    where: ExtraExpenseScalarWhereInput
    data: XOR<ExtraExpenseUpdateManyMutationInput, ExtraExpenseUncheckedUpdateManyWithoutFinancialRegistrationInput>
  }

  export type ExtraExpenseScalarWhereInput = {
    AND?: ExtraExpenseScalarWhereInput | ExtraExpenseScalarWhereInput[]
    OR?: ExtraExpenseScalarWhereInput[]
    NOT?: ExtraExpenseScalarWhereInput | ExtraExpenseScalarWhereInput[]
    id?: StringFilter<"ExtraExpense"> | string
    expenseType?: StringFilter<"ExtraExpense"> | string
    amount?: FloatFilter<"ExtraExpense"> | number
    startDate?: DateTimeFilter<"ExtraExpense"> | Date | string
    endDate?: DateTimeFilter<"ExtraExpense"> | Date | string
    financialRegistrationId?: StringFilter<"ExtraExpense"> | string
  }

  export type FinancialRegistrationCreateWithoutClientsInput = {
    id?: string
    expenses?: ExpenseCreateNestedManyWithoutFinancialRegistrationInput
    user: UserCreateNestedOneWithoutFinancialRegistrationInput
    Receivable?: ReceivableCreateNestedManyWithoutFinancialRegistrationInput
    ExtraExpense?: ExtraExpenseCreateNestedManyWithoutFinancialRegistrationInput
  }

  export type FinancialRegistrationUncheckedCreateWithoutClientsInput = {
    id?: string
    userId: string
    expenses?: ExpenseUncheckedCreateNestedManyWithoutFinancialRegistrationInput
    Receivable?: ReceivableUncheckedCreateNestedManyWithoutFinancialRegistrationInput
    ExtraExpense?: ExtraExpenseUncheckedCreateNestedManyWithoutFinancialRegistrationInput
  }

  export type FinancialRegistrationCreateOrConnectWithoutClientsInput = {
    where: FinancialRegistrationWhereUniqueInput
    create: XOR<FinancialRegistrationCreateWithoutClientsInput, FinancialRegistrationUncheckedCreateWithoutClientsInput>
  }

  export type ReceivableCreateWithoutClientInput = {
    id?: string
    serviceProvided: string
    amountToReceive: number
    serviceStartDate: Date | string
    serviceEndDate: Date | string
    financialRegistration: FinancialRegistrationCreateNestedOneWithoutReceivableInput
  }

  export type ReceivableUncheckedCreateWithoutClientInput = {
    id?: string
    serviceProvided: string
    amountToReceive: number
    serviceStartDate: Date | string
    serviceEndDate: Date | string
    financialRegistrationId: string
  }

  export type ReceivableCreateOrConnectWithoutClientInput = {
    where: ReceivableWhereUniqueInput
    create: XOR<ReceivableCreateWithoutClientInput, ReceivableUncheckedCreateWithoutClientInput>
  }

  export type ReceivableCreateManyClientInputEnvelope = {
    data: ReceivableCreateManyClientInput | ReceivableCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type FinancialRegistrationUpsertWithoutClientsInput = {
    update: XOR<FinancialRegistrationUpdateWithoutClientsInput, FinancialRegistrationUncheckedUpdateWithoutClientsInput>
    create: XOR<FinancialRegistrationCreateWithoutClientsInput, FinancialRegistrationUncheckedCreateWithoutClientsInput>
    where?: FinancialRegistrationWhereInput
  }

  export type FinancialRegistrationUpdateToOneWithWhereWithoutClientsInput = {
    where?: FinancialRegistrationWhereInput
    data: XOR<FinancialRegistrationUpdateWithoutClientsInput, FinancialRegistrationUncheckedUpdateWithoutClientsInput>
  }

  export type FinancialRegistrationUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenses?: ExpenseUpdateManyWithoutFinancialRegistrationNestedInput
    user?: UserUpdateOneRequiredWithoutFinancialRegistrationNestedInput
    Receivable?: ReceivableUpdateManyWithoutFinancialRegistrationNestedInput
    ExtraExpense?: ExtraExpenseUpdateManyWithoutFinancialRegistrationNestedInput
  }

  export type FinancialRegistrationUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expenses?: ExpenseUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
    Receivable?: ReceivableUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
    ExtraExpense?: ExtraExpenseUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
  }

  export type ReceivableUpsertWithWhereUniqueWithoutClientInput = {
    where: ReceivableWhereUniqueInput
    update: XOR<ReceivableUpdateWithoutClientInput, ReceivableUncheckedUpdateWithoutClientInput>
    create: XOR<ReceivableCreateWithoutClientInput, ReceivableUncheckedCreateWithoutClientInput>
  }

  export type ReceivableUpdateWithWhereUniqueWithoutClientInput = {
    where: ReceivableWhereUniqueInput
    data: XOR<ReceivableUpdateWithoutClientInput, ReceivableUncheckedUpdateWithoutClientInput>
  }

  export type ReceivableUpdateManyWithWhereWithoutClientInput = {
    where: ReceivableScalarWhereInput
    data: XOR<ReceivableUpdateManyMutationInput, ReceivableUncheckedUpdateManyWithoutClientInput>
  }

  export type FinancialRegistrationCreateWithoutExpensesInput = {
    id?: string
    clients?: ClientCreateNestedManyWithoutFinancialRegistrationInput
    user: UserCreateNestedOneWithoutFinancialRegistrationInput
    Receivable?: ReceivableCreateNestedManyWithoutFinancialRegistrationInput
    ExtraExpense?: ExtraExpenseCreateNestedManyWithoutFinancialRegistrationInput
  }

  export type FinancialRegistrationUncheckedCreateWithoutExpensesInput = {
    id?: string
    userId: string
    clients?: ClientUncheckedCreateNestedManyWithoutFinancialRegistrationInput
    Receivable?: ReceivableUncheckedCreateNestedManyWithoutFinancialRegistrationInput
    ExtraExpense?: ExtraExpenseUncheckedCreateNestedManyWithoutFinancialRegistrationInput
  }

  export type FinancialRegistrationCreateOrConnectWithoutExpensesInput = {
    where: FinancialRegistrationWhereUniqueInput
    create: XOR<FinancialRegistrationCreateWithoutExpensesInput, FinancialRegistrationUncheckedCreateWithoutExpensesInput>
  }

  export type FinancialRegistrationUpsertWithoutExpensesInput = {
    update: XOR<FinancialRegistrationUpdateWithoutExpensesInput, FinancialRegistrationUncheckedUpdateWithoutExpensesInput>
    create: XOR<FinancialRegistrationCreateWithoutExpensesInput, FinancialRegistrationUncheckedCreateWithoutExpensesInput>
    where?: FinancialRegistrationWhereInput
  }

  export type FinancialRegistrationUpdateToOneWithWhereWithoutExpensesInput = {
    where?: FinancialRegistrationWhereInput
    data: XOR<FinancialRegistrationUpdateWithoutExpensesInput, FinancialRegistrationUncheckedUpdateWithoutExpensesInput>
  }

  export type FinancialRegistrationUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clients?: ClientUpdateManyWithoutFinancialRegistrationNestedInput
    user?: UserUpdateOneRequiredWithoutFinancialRegistrationNestedInput
    Receivable?: ReceivableUpdateManyWithoutFinancialRegistrationNestedInput
    ExtraExpense?: ExtraExpenseUpdateManyWithoutFinancialRegistrationNestedInput
  }

  export type FinancialRegistrationUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clients?: ClientUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
    Receivable?: ReceivableUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
    ExtraExpense?: ExtraExpenseUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
  }

  export type ClientCreateWithoutReceivableInput = {
    id?: string
    name: string
    type: $Enums.ClientType
    address: string
    phone: string
    email: string
    financialRegistration: FinancialRegistrationCreateNestedOneWithoutClientsInput
  }

  export type ClientUncheckedCreateWithoutReceivableInput = {
    id?: string
    name: string
    type: $Enums.ClientType
    address: string
    phone: string
    email: string
    financialRegistrationId: string
  }

  export type ClientCreateOrConnectWithoutReceivableInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutReceivableInput, ClientUncheckedCreateWithoutReceivableInput>
  }

  export type FinancialRegistrationCreateWithoutReceivableInput = {
    id?: string
    clients?: ClientCreateNestedManyWithoutFinancialRegistrationInput
    expenses?: ExpenseCreateNestedManyWithoutFinancialRegistrationInput
    user: UserCreateNestedOneWithoutFinancialRegistrationInput
    ExtraExpense?: ExtraExpenseCreateNestedManyWithoutFinancialRegistrationInput
  }

  export type FinancialRegistrationUncheckedCreateWithoutReceivableInput = {
    id?: string
    userId: string
    clients?: ClientUncheckedCreateNestedManyWithoutFinancialRegistrationInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutFinancialRegistrationInput
    ExtraExpense?: ExtraExpenseUncheckedCreateNestedManyWithoutFinancialRegistrationInput
  }

  export type FinancialRegistrationCreateOrConnectWithoutReceivableInput = {
    where: FinancialRegistrationWhereUniqueInput
    create: XOR<FinancialRegistrationCreateWithoutReceivableInput, FinancialRegistrationUncheckedCreateWithoutReceivableInput>
  }

  export type ClientUpsertWithoutReceivableInput = {
    update: XOR<ClientUpdateWithoutReceivableInput, ClientUncheckedUpdateWithoutReceivableInput>
    create: XOR<ClientCreateWithoutReceivableInput, ClientUncheckedCreateWithoutReceivableInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutReceivableInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutReceivableInput, ClientUncheckedUpdateWithoutReceivableInput>
  }

  export type ClientUpdateWithoutReceivableInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    financialRegistration?: FinancialRegistrationUpdateOneRequiredWithoutClientsNestedInput
  }

  export type ClientUncheckedUpdateWithoutReceivableInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    financialRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialRegistrationUpsertWithoutReceivableInput = {
    update: XOR<FinancialRegistrationUpdateWithoutReceivableInput, FinancialRegistrationUncheckedUpdateWithoutReceivableInput>
    create: XOR<FinancialRegistrationCreateWithoutReceivableInput, FinancialRegistrationUncheckedCreateWithoutReceivableInput>
    where?: FinancialRegistrationWhereInput
  }

  export type FinancialRegistrationUpdateToOneWithWhereWithoutReceivableInput = {
    where?: FinancialRegistrationWhereInput
    data: XOR<FinancialRegistrationUpdateWithoutReceivableInput, FinancialRegistrationUncheckedUpdateWithoutReceivableInput>
  }

  export type FinancialRegistrationUpdateWithoutReceivableInput = {
    id?: StringFieldUpdateOperationsInput | string
    clients?: ClientUpdateManyWithoutFinancialRegistrationNestedInput
    expenses?: ExpenseUpdateManyWithoutFinancialRegistrationNestedInput
    user?: UserUpdateOneRequiredWithoutFinancialRegistrationNestedInput
    ExtraExpense?: ExtraExpenseUpdateManyWithoutFinancialRegistrationNestedInput
  }

  export type FinancialRegistrationUncheckedUpdateWithoutReceivableInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clients?: ClientUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
    ExtraExpense?: ExtraExpenseUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
  }

  export type FinancialRegistrationCreateWithoutExtraExpenseInput = {
    id?: string
    clients?: ClientCreateNestedManyWithoutFinancialRegistrationInput
    expenses?: ExpenseCreateNestedManyWithoutFinancialRegistrationInput
    user: UserCreateNestedOneWithoutFinancialRegistrationInput
    Receivable?: ReceivableCreateNestedManyWithoutFinancialRegistrationInput
  }

  export type FinancialRegistrationUncheckedCreateWithoutExtraExpenseInput = {
    id?: string
    userId: string
    clients?: ClientUncheckedCreateNestedManyWithoutFinancialRegistrationInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutFinancialRegistrationInput
    Receivable?: ReceivableUncheckedCreateNestedManyWithoutFinancialRegistrationInput
  }

  export type FinancialRegistrationCreateOrConnectWithoutExtraExpenseInput = {
    where: FinancialRegistrationWhereUniqueInput
    create: XOR<FinancialRegistrationCreateWithoutExtraExpenseInput, FinancialRegistrationUncheckedCreateWithoutExtraExpenseInput>
  }

  export type FinancialRegistrationUpsertWithoutExtraExpenseInput = {
    update: XOR<FinancialRegistrationUpdateWithoutExtraExpenseInput, FinancialRegistrationUncheckedUpdateWithoutExtraExpenseInput>
    create: XOR<FinancialRegistrationCreateWithoutExtraExpenseInput, FinancialRegistrationUncheckedCreateWithoutExtraExpenseInput>
    where?: FinancialRegistrationWhereInput
  }

  export type FinancialRegistrationUpdateToOneWithWhereWithoutExtraExpenseInput = {
    where?: FinancialRegistrationWhereInput
    data: XOR<FinancialRegistrationUpdateWithoutExtraExpenseInput, FinancialRegistrationUncheckedUpdateWithoutExtraExpenseInput>
  }

  export type FinancialRegistrationUpdateWithoutExtraExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    clients?: ClientUpdateManyWithoutFinancialRegistrationNestedInput
    expenses?: ExpenseUpdateManyWithoutFinancialRegistrationNestedInput
    user?: UserUpdateOneRequiredWithoutFinancialRegistrationNestedInput
    Receivable?: ReceivableUpdateManyWithoutFinancialRegistrationNestedInput
  }

  export type FinancialRegistrationUncheckedUpdateWithoutExtraExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clients?: ClientUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
    Receivable?: ReceivableUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
  }

  export type RoomCreateManyOwnerInput = {
    id?: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type MessageCreateManyUserInput = {
    id?: string
    content: string
    chatId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectsCreateManyOwnerInput = {
    id?: string
    name: string
    color: string
    usersIds?: ProjectsCreateusersIdsInput | string[]
    privacy?: $Enums.Privacy
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyResponsibleInput = {
    id?: string
    title: string
    information: string
    files: string
    status?: $Enums.Status
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnotationCreateManyUserInput = {
    id?: string
    title: string
    color: string
    information: string
  }

  export type EmailTokenCreateManyUserInput = {
    id?: string
    token: string
    validated?: boolean
    attempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    senderId: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManySenderInput = {
    id?: string
    userId: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoRoomCreateManyOwnerInput = {
    id?: string
    roomId: string
    roomLink: string
  }

  export type FinancialRegistrationCreateManyUserInput = {
    id?: string
  }

  export type RoomUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chats?: ChatUpdateManyWithoutRoomNestedInput
    owner?: UserUpdateOneWithoutOwnedRoomsNestedInput
    VideoRoom?: VideoRoomUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chats?: ChatUncheckedUpdateManyWithoutRoomNestedInput
    VideoRoom?: VideoRoomUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chats?: ChatUpdateManyWithoutRoomNestedInput
    users?: UserUpdateManyWithoutRoomsNestedInput
    VideoRoom?: VideoRoomUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chats?: ChatUncheckedUpdateManyWithoutRoomNestedInput
    users?: UserUncheckedUpdateManyWithoutRoomsNestedInput
    VideoRoom?: VideoRoomUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    usersIds?: ProjectsUpdateusersIdsInput | string[]
    privacy?: EnumPrivacyFieldUpdateOperationsInput | $Enums.Privacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    usersIds?: ProjectsUpdateusersIdsInput | string[]
    privacy?: EnumPrivacyFieldUpdateOperationsInput | $Enums.Privacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    usersIds?: ProjectsUpdateusersIdsInput | string[]
    privacy?: EnumPrivacyFieldUpdateOperationsInput | $Enums.Privacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectsUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    usersIds?: ProjectsUpdateusersIdsInput | string[]
    privacy?: EnumPrivacyFieldUpdateOperationsInput | $Enums.Privacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectsUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    usersIds?: ProjectsUpdateusersIdsInput | string[]
    privacy?: EnumPrivacyFieldUpdateOperationsInput | $Enums.Privacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutProjectsNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectsUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    usersIds?: ProjectsUpdateusersIdsInput | string[]
    privacy?: EnumPrivacyFieldUpdateOperationsInput | $Enums.Privacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutResponsibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    files?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectsUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutResponsibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    files?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutResponsibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    files?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnotationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
  }

  export type AnnotationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
  }

  export type AnnotationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
  }

  export type EmailTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSendNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoRoomUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomLink?: StringFieldUpdateOperationsInput | string
    room?: RoomUpdateOneRequiredWithoutVideoRoomNestedInput
  }

  export type VideoRoomUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    roomLink?: StringFieldUpdateOperationsInput | string
  }

  export type VideoRoomUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    roomLink?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialRegistrationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clients?: ClientUpdateManyWithoutFinancialRegistrationNestedInput
    expenses?: ExpenseUpdateManyWithoutFinancialRegistrationNestedInput
    Receivable?: ReceivableUpdateManyWithoutFinancialRegistrationNestedInput
    ExtraExpense?: ExtraExpenseUpdateManyWithoutFinancialRegistrationNestedInput
  }

  export type FinancialRegistrationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clients?: ClientUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
    Receivable?: ReceivableUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
    ExtraExpense?: ExtraExpenseUncheckedUpdateManyWithoutFinancialRegistrationNestedInput
  }

  export type FinancialRegistrationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCreateManyProjectInput = {
    id?: string
    title: string
    information: string
    files: string
    status?: $Enums.Status
    responsibleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rooms?: RoomUncheckedUpdateManyWithoutUsersNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUncheckedUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    files?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible?: UserUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    files?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    files?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateManyRoomInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoRoomCreateManyRoomInput = {
    id?: string
    ownerId: string
    roomLink: string
  }

  export type ChatUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUpdateManyWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    projects?: ProjectsUncheckedUpdateManyWithoutUsersNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectsUncheckedUpdateManyWithoutOwnerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutResponsibleNestedInput
    annotation?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    emailToken?: EmailTokenUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sendNotification?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    videoRoom?: VideoRoomUncheckedUpdateManyWithoutOwnerNestedInput
    financialRegistration?: FinancialRegistrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dateBirth?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type VideoRoomUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomLink?: StringFieldUpdateOperationsInput | string
    owner?: UserUpdateOneRequiredWithoutVideoRoomNestedInput
  }

  export type VideoRoomUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    roomLink?: StringFieldUpdateOperationsInput | string
  }

  export type VideoRoomUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    roomLink?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateManyChatInput = {
    id?: string
    content: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateManyFinancialRegistrationInput = {
    id?: string
    name: string
    type: $Enums.ClientType
    address: string
    phone: string
    email: string
  }

  export type ExpenseCreateManyFinancialRegistrationInput = {
    id?: string
    type: $Enums.ExpenseType
    amount: number
    recurringMonth: number
    contractStartDate: Date | string
    contractEndDate?: Date | string | null
  }

  export type ReceivableCreateManyFinancialRegistrationInput = {
    id?: string
    clientId: string
    serviceProvided: string
    amountToReceive: number
    serviceStartDate: Date | string
    serviceEndDate: Date | string
  }

  export type ExtraExpenseCreateManyFinancialRegistrationInput = {
    id?: string
    expenseType: string
    amount: number
    startDate: Date | string
    endDate: Date | string
  }

  export type ClientUpdateWithoutFinancialRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    Receivable?: ReceivableUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutFinancialRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    Receivable?: ReceivableUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutFinancialRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseUpdateWithoutFinancialRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    amount?: FloatFieldUpdateOperationsInput | number
    recurringMonth?: IntFieldUpdateOperationsInput | number
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExpenseUncheckedUpdateWithoutFinancialRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    amount?: FloatFieldUpdateOperationsInput | number
    recurringMonth?: IntFieldUpdateOperationsInput | number
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExpenseUncheckedUpdateManyWithoutFinancialRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    amount?: FloatFieldUpdateOperationsInput | number
    recurringMonth?: IntFieldUpdateOperationsInput | number
    contractStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceivableUpdateWithoutFinancialRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceProvided?: StringFieldUpdateOperationsInput | string
    amountToReceive?: FloatFieldUpdateOperationsInput | number
    serviceStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutReceivableNestedInput
  }

  export type ReceivableUncheckedUpdateWithoutFinancialRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceProvided?: StringFieldUpdateOperationsInput | string
    amountToReceive?: FloatFieldUpdateOperationsInput | number
    serviceStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivableUncheckedUpdateManyWithoutFinancialRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceProvided?: StringFieldUpdateOperationsInput | string
    amountToReceive?: FloatFieldUpdateOperationsInput | number
    serviceStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtraExpenseUpdateWithoutFinancialRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtraExpenseUncheckedUpdateWithoutFinancialRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtraExpenseUncheckedUpdateManyWithoutFinancialRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivableCreateManyClientInput = {
    id?: string
    serviceProvided: string
    amountToReceive: number
    serviceStartDate: Date | string
    serviceEndDate: Date | string
    financialRegistrationId: string
  }

  export type ReceivableUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceProvided?: StringFieldUpdateOperationsInput | string
    amountToReceive?: FloatFieldUpdateOperationsInput | number
    serviceStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    financialRegistration?: FinancialRegistrationUpdateOneRequiredWithoutReceivableNestedInput
  }

  export type ReceivableUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceProvided?: StringFieldUpdateOperationsInput | string
    amountToReceive?: FloatFieldUpdateOperationsInput | number
    serviceStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    financialRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type ReceivableUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceProvided?: StringFieldUpdateOperationsInput | string
    amountToReceive?: FloatFieldUpdateOperationsInput | number
    serviceStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    financialRegistrationId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectsCountOutputTypeDefaultArgs instead
     */
    export type ProjectsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomCountOutputTypeDefaultArgs instead
     */
    export type RoomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatCountOutputTypeDefaultArgs instead
     */
    export type ChatCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FinancialRegistrationCountOutputTypeDefaultArgs instead
     */
    export type FinancialRegistrationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FinancialRegistrationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientCountOutputTypeDefaultArgs instead
     */
    export type ClientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnnotationDefaultArgs instead
     */
    export type AnnotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnnotationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectsDefaultArgs instead
     */
    export type ProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomDefaultArgs instead
     */
    export type RoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoRoomDefaultArgs instead
     */
    export type VideoRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoRoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatDefaultArgs instead
     */
    export type ChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailTokenDefaultArgs instead
     */
    export type EmailTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FinancialRegistrationDefaultArgs instead
     */
    export type FinancialRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FinancialRegistrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientDefaultArgs instead
     */
    export type ClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseDefaultArgs instead
     */
    export type ExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReceivableDefaultArgs instead
     */
    export type ReceivableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReceivableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExtraExpenseDefaultArgs instead
     */
    export type ExtraExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExtraExpenseDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}